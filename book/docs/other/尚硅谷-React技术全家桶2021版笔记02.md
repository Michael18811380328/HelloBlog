# React 全家桶入门教程 02

## 第六章 react-ui

常用的开源组件库：material-UI  ant-design

教程版本时 4.8.2，项目中使用 2.x 版本，文档和实际代码可能有差异；注意更新。

### 94 antd的基本使用

直接查阅官网，需要哪个使用哪个就行

注意版本：目前项目中使用 2 版本，正式4版本已经发布，配置参数有不少差距

### 95 antd样式的按需引入

我们开始引入全部的CSS文件，实际上体积比较大（60kb），性能不好，最好使用按需引入

在 create-react-app 脚手架中，可以进行下面的配置

~~~bash
npm install react-app-rewired customize-cra babel-plugin-import
~~~

改写脚本命令

~~~json
"script": {
  "start": "react-app-rewired start",
  "build": "react-app-rewired build",
  "test": "react-app-rewired test",
}
~~~

增加单独的配置文件 config-overrides.js （需要 customize-cra 库，处理自定义配置）

~~~js
module.exports = function override(config, env) {
  // 这里可以改写默认的 webpack 配置文件
  return config;
}
~~~

实际上改成这样

~~~js
const { override, fixBabelImports } = require('customize-cra');

module.exports = override(
	fixBabelImports('import', {
    libraryName: 'antd',
    libraryDirectory: 'es',
    style: 'css',
  })
);
~~~

更改后，就不需要在组件内部单独引入对应的样式文件了

### 96 antd 自定义主题

Ant-design 使用 less 作为样式文件，所以自定义样式，需要覆盖原来的样式文件。

~~~bash
npm install less less-loader
~~~

更改配置文件

~~~js
const { override, fixBabelImports, addLessLoader } = require('customize-cra');

module.exports = override(
	fixBabelImports('import', {
    libraryName: 'antd',
    libraryDirectory: 'es',
    style: true,
  }),
  // 注意：这里官网配置会报错，因为 lessLoader 版本更新了，参数更改了
  addLessLoader({
    lessOptions: {
      javascriptEnabled: true,
    	modifyVars: { '@primary-color': '#fff' },
    }
  }),
);
~~~







## 第七章 redux

### 97 redux 基本了解

- 定义：redux 是专门状态管理的第三方库，和 react 没有直接联系（不是Facebook 团队出品）集中式管理 react 中多个组件共享的状态
- 优点：解决了多个组件共享状态的问题，适应于不同组件通信比较复杂的情况
- 缺点：学习和使用成本较高（简单项目不用，复杂项目使用）
- 是否全部 state 使用 redux?  项目中，可以把共享的 state 使用 redux 管理，组件私有的 state 维护在内部实现。

个人想法：如果多个组件需要共享状态，最好状态和组件是对应的，分析组件拆分的逻辑是否合理，优先考虑状态提升，次要考虑 eventBus，最后考虑 redux。

### 98 Redux 基本概念和工作流程

个人理解的工作流程

（这里有图片）

0、初始化 Store 调用 Reducer 并设置初始状态

1、React 组件想要更新状态，发出一个 dispatch(Action),  {type, data}

2、Store 接收到 Action，转发给 Reducer 处理（switch 处理多个 type）

3、Reducer 根据原状态 prevState 和 Action，计算出新的状态 newState ，并返回到 Store

4、Store 中状态更新，重新渲染整个组件，组件 getState 获取数据，界面刷新（需要提前订阅 Store 更新的事件）

说明：初始 Reducer 时，prevState 是 undefined, type 是随机字符串

基本概念

- action 动作对象（type 唯一，data 可选参数）
- reducer 用于初始化数据，或者更新数据（根据旧 state 和 action 产生新的 state 的纯函数）
- store 连接 state action reducer 的核心，主要使用

~~~js
import { createStore } form 'redux';
import demo_reducer from './demo_reducer';

const store = createStore(demo_reducer);

export default store;
~~~

基本 API

~~~js
import store from './store';

store.getState();
store.dispatch(action);
store.subscribe(callback);
~~~

### 99 使用 react 实现的求和案例

实现一个简单的加减法计算器

~~~jsx
import React from 'react';

export default class Count extends React.Component {
  
  state = {
    result: 0,
  }
  
  onAdd = () => {
    this.setState({
      result: this.state.result + this.selectRef.value * 1,
    });
  }
  
  onDec = () => {
    this.setState({
      result: this.state.result - this.selectRef.value * 1,
    });
  }
  
  render() {
    return (
      <div>结果是 {this.state.result} </div>
      <select ref={node => this.selectRef = node}>
      	<option value='1'>1</option>
        <option value='2'>2</option>
      </select>
      <button onClick={this.onAdd}>加</button>
      <button onClick={this.onDec}>减</button>
    );
  }
}
~~~

### 100 实现基本计算器

基本实现：入口文件 index 组件 Count store reducer 

Store 整个应用维护一个 store 管理全部的 reducer

~~~js
import { createStore } from 'redux';
import countReducer from './count_reducer';

const store = createStore(countReducer);

export default store;
~~~

Reducer 本质是一个函数，Store 会调用这个函数，每一个 reducer 对应一个组件

~~~js
const initState = 0;

// 首次 Store 初始化时，preState 是 undefined，action.type 是乱码，所以使用初始值，直接返回
function countReducer(preState = initState, action) {
  const { type, data } = action;
  switch (type) {
    case 'add':
      return preState + data;
    case 'reduce':
      return preState - data;
    default:
      return preState;
  }
}

export default countReducer;
~~~

组件中获取 state，发出 action

~~~js
import store from './store';

// 组件内部的 state 不变，和 redux 不冲突
state = {
  name: 'Mike'
};

// 可以在组件内部监听状态变化（最好在全局顶层组件监听状态变化，触发回调函数）
componentDidMount() {
  // 参数是一个回调函数（状态变化后，强制更新这个组件）
  store.subscribe(() => {
    this.forceUpdate();
  })
}

onAdd = () => {
  let action = new Action({ type: 'xxx', data: 1 });
  store.dispatch(action);
}
~~~

最好的办法是入口函数监听 state 变化，并触发全局重新渲染（因为 diff 算法，确保实际性能可以）

~~~js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import store from './redux/store';

ReactDOM.render(<App/>, document.getElementById('root'));

// 更新 state 后，渲染全部组件
store.subscribe(() => {
  ReactDOM.render(<App/>, document.getElementById('root'));
});
~~~

小结：使用 redux 步骤

1、检查哪些 state 是公共部分，去掉组件原来的 state

2、src 下面建立 redux 目录，内部写入 store reducer 作为单独的文件目录

3、store 中，引入 createStore(reducer) 然后暴露这个 store 对象

4、reducer 中，处理初始化状态和更新状态（纯函数）

5、index 中监听 store 状态改变，改变后重新渲染组件。redux 只处理状态管理，状态更新后渲染页面的步骤需要根据需求完成

### 101 redux 完整版

在前一节课程基础上，把 count_action 单独拿出来做成一个文件，专门为 Count 生成 Action

~~~js
export const addAction = (data) => { type: 'add', data };
export const decAction = (data) => { type: 'dec', data };
~~~

PS 如果箭头函数的返回值是对象，那么需要用括号包起来

~~~js
export const test = para => ({ type: 'add', data });
~~~

这样写，可能产生魔法字符串，生产中如果 Action 比较多，最好使用常量文件

~~~js
export const INCREASE = 'increase';
export const DECREASE = 'decrease';
~~~

然后在 action.js 和 reducer 中引入 constant 常量，即可解决魔法字符串问题。







求和案例-异步action版

对react-redux的理解

连接容器组件与UI组件

react-redux基本使用

优化1-简写mapDispatch

优化2-Provider组件的使用

优化3-整合UI组件与容器组件

数据共享-编写Person组件

数据共享-编写Person组件的reducer

数据共享-完成数据共享

纯函数

redux开发者工具

最终版

项目打包运行





## 第八章 扩展

### 116 setState 的参数

setState 第一个参数是必选的，可以是对象或者函数（函数返回一个对象）；第二个参数是可选的，状态更新后的回调函数。

~~~js
this.setState({
  num: 1
}, callback);

this.setState((state, props) => {
  return {
    num: state + this.props.num,
  };
}, callback);

// 这两种写法效果一样
this.setState({ num: this.state.num + this.props.num });
~~~

两个写法的效果一致，对象是函数的语法糖（简写）。

使用原则：如果新状态不依赖原始的 state 和 props，优先使用对象。如果新状态依赖原始的状态，可以使用函数。

个人想法：优先使用对象（简单可读）；如果其他同事使用函数作为参数，也应该熟悉。



### 117 lazyload 和 suspense

问题：如果界面中组件很多，首次加载太消耗性能，那么可以首次加载一部分组件，后续组件懒加载。

例如：一个组件中有20个路由，用户可能只看5个，那么不需要首次加载全部的组件，可以只加载5个，用户点击其他组件，通过网络请求再加载其他的组件。

~~~js
import { React, lazy, Suspense } from 'react';
import { NavLink, Route } from 'react-router-dom';
import Loading from './loading';

// 把需要懒加载的组件，使用 lazy 函数包裹（参数是函数，返回值是组件）
const Login = lazy(() => import('./Login'));
const Forget = lazy(() => import('./Forget'));
const Main = lazy(() => import('./Main'));

render() {
  // 需要懒加载的组件，使用 Suspense 包裹一层，设置 fallback 为加载中的动画效果
  return (
    <Suspense fallback={<Loading/>}>
      <Route path="/login" component={Login}/>
      <Route path="/forget" component={Forget}/>
      <Route path="/main" component={Main}/>
    </Suspense>
  );
}
~~~

个人想法：如果全部使用懒加载，那么最后 webpack 打包结果是否有很多文件，是否便于维护？如果多项目协同开发，是否合适？



扩展3-stateHook

扩展4-EffectHook

扩展5-RefHook

扩展6-Fragment

扩展7-Context

### 123 扩展8-PureComponent

Component 的性能问题：只要 setState 执行，即使不改变状态数据，组件也会重新渲染。如果当前组件渲染，那么会自动重新渲染子组件（效率较低）。shouldComponentUpdate 默认返回 true，所以组件会重新渲染。

解决思路：当 props 或者 state 变化时，才重新渲染

解决方法

1、简单组件（props 和 state 是简单数据类型），直接使用 PureComponent ，在组件 state 或者 props 中变化后才重新更新组件。注意：如果 props 是对象，这里实现浅对比判断是否渲染。如果对象引用没变化，只改变了值，可能不会引起组件重新渲染。

2、复杂组件（props 可能是复杂数据类型）需要在 shouldComponentUpdate 中，判断每一个变量，然后判断组件是否更新。

~~~js
shouldComponentUpdate(nextProps, nextState) {
  console.log(this.state, nextState);
  console.log(this.props, nextProps);
}
~~~

在 setState 阶段，最好直接更改对象，避免只更改引用

~~~js
// standard
this.setState({ name: 10 });

// bad
let state = this.state;
state.name = 10;
this.setState(state);
~~~

如果 state 中是数组，最好实现深复制，避免 push 操作

~~~js
state = {
  list: [1, 2, 3],
};

// bad
let list = this.state.list;
list.push(4);
this.setState(list); // 这样 list 指针没有变化，pureComponent 可能出错

// good
let list = this.state.list;
this.setState({ list: [...list, 4] });
~~~



扩展9-renderProps

扩展10-ErrorBoundary

组件间通信方式总结
