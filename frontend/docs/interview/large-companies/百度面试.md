## 百度面试总结

1、实现一个函数，判断输入是不是回文字符串。

```js
function run(input) {
  if (typeof input !== 'string') return false;
  return input.split('').reverse().join('') === input;
}
```

2、两种以上方式实现已知或者未知宽度的垂直水平居中。

```scss
// 1
.wraper {  
  position: relative;  
  .box {    
    position: absolute;    
    top: 50%;    
    left: 50%;    
    width: 100px;    
    height: 100px;    
    margin: -50px 0 0 -50px;  
  }
}

// 2
.wraper {  
  position: relative;  
  .box {    
    position: absolute;    
    top: 50%;    
    left: 50%;    
    transform: translate(-50%, -50%);  
  }
}

// 3
.wraper {  
  .box {    
    display: flex;    
    justify-content:center;    
    align-items: center;    
    height: 100px;  
  }
}

// 4
.wraper { 
  display: table;  
  .box {    
    display: table-cell;    
    vertical-align: middle;  
  }
}
```

3、实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置。

```js
const box = document.getElementById('box');

function isIcon(target) {
  return target.className.includes('icon');
}
box.onClick = function(e) {
  e.stopPropagation();
  const target = e.target;
  if (isIcon(target)) {
    target.style.border = '1px solid red';
  }
}
const doc = document;
doc.onclick = function(e) {
  const children = box.children;
  for (let i; i < children.length; i++) {
    if (isIcon(children[i])) {
      children[i].style.border = 'none';
    }
  }
}
```

4、请简单实现双向数据绑定mvvm。

```
<input id="input"/>
```

```js
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
    set(value) {
        input.value = value;
        this.value = value;
    }
});
input.onChange = function(e) {
    data.text = e.target.value;
}
```

5、实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)

```js
var instance = null;
class Storage {
  static getInstance() {
    if (!instance) {
      instance = new Storage();
    }
    return instance;
  }
  setItem = (key, value) => localStorage.setItem(key, value), getItem = key => localStorage.getItem(key)
}
```



**Q1 你说说你用react有什么坑点？**

1、JSX做表达式判断时候，需要强转为boolean类型，如：

```jsx
render() {  
  const b = 0;  
  return (
    <div>
      {!!b && <div>这是一段文本</div>}  
    </div>
  );
}
```

如果不使用 !!b 进行强转数据类型，会在页面里面输出 0。

2、尽量不要在 componentWillReviceProps 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。

3、给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null。详情见

4、遍历子节点的时候，不要用 index 作为组件的 key 进行传入。



**Q2 我现在有一个button，要用react在上面绑定点击事件，要怎么做？**

```
class Demo {  render() {    return <button onClick={(e) => {      alert('我点击了按钮')    }}>      按钮    </button>  }}
```

**Q3 接上一个问题，你觉得你这样设置点击事件会有什么问题吗？**

由于onClick使用的是匿名函数，所有每次重渲染的时候，会把该onClick当做一个新的prop来处理，会将内部缓存的onClick事件进行重新赋值，所以相对直接使用函数来说，可能有一点的性能下降（个人认为）。

修改：

```
class Demo {  onClick = (e) => {    alert('我点击了按钮')  }  render() {    return <button onClick={this.onClick}>      按钮    </button>  }}
```

当然你在内部声明的不是箭头函数，然后你可能需要在设置onClick的时候使用bind绑定上下文，这样的效果和先前的使用匿名函数差不多，因为bind会返回新的函数，也会被react认为是一个新的prop。

**Q4 你说说event loop吧**

首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务macrotask（setTimeout、setInterval）进行执行。

**Q5 说说事件流吧**

事件流分为两种，捕获事件流和冒泡事件流。

- 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。
- 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。

事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。

**Q6 我现在有一个进度条，进度条中间有一串文字，当我的进度条覆盖了文字之后，文字要与进度条反色，怎么实现？**

当时我给的是js的方案，在进度条宽度变化的时候，计算盖过每一个文字的50%，如果超过，设置文字相反颜色。

当然css也有对应的方案，也就是 mix-blend-mode，我并没有接触过。

对应html也有对应方案，也就设置两个相同位置但是颜色相反的dom结构在重叠在一起，顶层覆盖底层，最顶层的进度条取overflow为hidden，其宽度就为进度。





**Q1 你为什么要离开上一家公司？**

\-

**Q2 你觉得理想的前端地位是什么？**

\-

**Q3 那你意识到问题所在，你又尝试过解决问题吗？**



**Q1 说一下你上一家公司的一个整体开发流程吧**

\-

**Q2 react 的虚拟dom是怎么实现的**

首先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点。

**Q3 react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候。**

通常我们输出节点的时候都是map一个数组然后返回一个ReactNode，为了方便react内部进行优化，我们必须给每一个reactNode添加key，这个key prop在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个reactNode添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件。

**Q4 我现在有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，[2,1,4,3]。。。。你这个算法的时间复杂度是多少**

这个我没写出来，大概给了个思路，将每一个数组拆除俩个小数组进行求它的全排列，然后得到的结果互相之间又进行全排列，然后把最后的结果连接起来。。。

感兴趣的同学见数组全排列



**Q5 我现在有一个背包，容量为m，然后有n个货物，重量分别为w1,w2,w3...wn，每个货物的价值是v1,v2,v3...vn，w和v没有任何关系，请求背包能装下的最大价值。**

这个我也没写出来，也给了个思路，首先使用Q4的方法得到货物重量数组的全组合（包括拆分成小数组的全组合），然后计算每一个组合的价值，并进行排序，然后遍历数组，找到价值较高切刚好能装进背包m的组合。

本题 `动态规划面试题`，感兴趣的同学请自行百度或者谷歌。



**Q1 请说一下你的上一家公司的研发发布流程。**

\-

**Q2 你说一下webpack的一些plugin，怎么使用webpack对项目进行优化。**

正好最近在做webpack构建优化和性能优化的事儿，当时吹了大概15~20分钟吧，插件请见webpack插件归纳总结。

构建优化：

1. 减少编译体积 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime
2. 并行编译 happypack、thread-loader、uglifyjsWebpackPlugin开启并行
3. 缓存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin开启缓存、babel-loader开启缓存
4. 预编译 dllWebpackPlugin && DllReferencePlugin、auto-dll-webapck-plugin

性能优化：

1. 减少编译体积 Tree-shaking、Scope Hositing
2. hash缓存 webpack-md5-plugin
3. 拆包 splitChunksPlugin、import()、require.ensure

> Q3 es6 class 的new实例和es5的new实例有什么区别

这个我觉得是一样的（当时因为很少看babel编译之后的结果），面试官说不一样。。。后来我看了一下babel的编译结果，发现只是类的方法声明的过程不一样而已，最后new的结果是一样的。。。具体答案现在我也不知道。。。

**Q4 看你简历上写了canvas，你说一下为什么canvas的图片为什么过有跨域问题**

canvas图片为什么跨域我不知道，至今没查出来，也差不多，大概跨域原因和浏览器跨域的原因是一样的吧。

**Q5 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块**

使用getImageData获取像素数组，然后遍历数组，把在遍历节点的过程中，查看节点上下左右的像素颜色是否相同，如果相同，然后设置标识，最后groupBy一下所有像素。（这是我当时的方案）

其他更好的答案见地址

**Q6 请手写实现一个promise**

这个就不写了，详情见promise实现原理

注：四面是一个超级可爱的小姐姐，电脑给我让我写完之后，我说我写得差不多了，然后电脑给她，然后她竟然默默的在看我的代码，尝试寻找我的思路，也没有问我实现思路是啥，然后我就问她，你不应该是让我给你解释我的代码思路吗。。。你竟然在尝试寻找我的思路，我自己都不知道我自己是思路是啥。。。然后我两都笑了，哈哈哈。最后结束的时候我说我午饭还没吃，她还叫了另外一个小哥哥先带了下去吃饭，真是一个善良的小姐姐，非常感谢。



**Q1 你说一下你的技术有什么特点**

\-

**Q2 说一下你觉得你最得意的一个项目？你这个项目有什么缺陷，弊端吗？**

\-

**Q3 现在有那么一个团队，假如让你来做技术架构，你会怎么做？**

考虑到团队每一个前端的技术栈可能不一致，这个时候我可能选择微前端架构，让每个人负责的模块可以单独开发，单独部署，单独回滚，不依赖于其他项目模块，在尽可能的情况下节约团队成员之间的学习成本，当然这肯定也有缺点，那就是每个模块都需要一个前端项目，单独部署，单独回滚无疑也加大了运维成本。

**Q4 说一下你上一家公司的主要业务流程，你参与到其中了吗？**





**Q2 说说从输入URL到看到页面发生的全过程，越详细越好**

1. 首先浏览器主进程接管，开了一个下载线程。

2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。

3. 将下载完的内容转交给Renderer进程管理。

4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。

5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。

6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。

7. 绘制结束后，关闭TCP连接，过程有四次挥手。

   

**Q3 你刚刚说了三次握手，四次挥手，那你描述一下？**

本人对计算机网络的这些概念一直不是很熟悉，所以这个问题回答不会，这里mark下文章，感兴趣的同学查看地址

**Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？**

css在加载过程中不会影响到DOM树的生成，但是会影响到Render树的生成，进而影响到layout，所以一般来说，style的link标签需要尽量放在head里面，因为在解析DOM树的时候是自上而下的，而css样式又是通过异步加载的，这样的话，解析DOM树下的body节点和加载css样式能尽可能的并行，加快Render树的生成的速度。

js脚本应该放在底部，原因在于js线程与GUI渲染线程是互斥的关系，如果js放在首部，当下载执行js的时候，会影响渲染行程绘制页面，js的作用主要是处理交互，而交互必须得先让页面呈现才能进行，所以为了保证用户体验，尽量让页面先绘制出来。

**Q5 现在有一个函数A和函数B，请你实现B继承A**

```js
// 方式1
function B(){}
function A(){}
B.prototype = new A();

// 方式2
function A(){}
function B(){  
  A.call(this);
}

// 方式3
function B(){}
function A(){}
B.prototype = new A();
function B(){  
  A.call(this);
}
```

**Q6 刚刚你在Q5中说的几种继承的方式，分别说说他们的优缺点**

- 方式1：简单易懂，但是无法实现多继承，父类新增原型方法/原型属性，子类都能访问到
- 方式2：可以实现多继承，但是只能继承父类的实例属性和方法，不能继承原型属性/方法
- 方式3：可以继承实例属性/方法，也可以继承原型属性/方法，但是示例了两个A的构造函数

**Q7 说说CSS中几种垂直水平居中的方式**

参考前面百度一面笔试题Q2

**Q8 Q7中说的flex布局，垂直水平居中必须知道宽度吗？**

是的，必须知道高度(脑子进水了回答了必须知道，其实答案是不需要知道高度的)

**Q9 描述一下this**

this，函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，nodejs为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里。

**Q10 说一下浏览器的缓存机制**

浏览器缓存机制有两种，一种为强缓存，一种为协商缓存。

对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。

对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存。

协商缓存方案：

- Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。Exprires的缺陷是必须保证服务端时间和客户端时间严格同步。
- Cache-control：max-age，表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，
- If-None-Match/ETag：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回If-None-Match标识是否表示匹配。
- Last-modified/If-Modified-Since：第一次请求的时候服务端返回Last-modified表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比。

**Q11 ETag是这个字符串是怎么生成的？**

没答出来，我当时猜是根据文件内容或者最后修改时间进行的加密算法。其实官方没有明确指定生成ETag值的方法。 通常，使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号。

**Q12 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？**

1. 该组件需要提供hook指定渲染位置，默认渲染在body下面。
2. 然后改组件可以指定外层样式，如宽度等
3. 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。
4. 另外组件是可控的，需要外层传入visible表示是否可见。
5. 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。
6. 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。
7. 组件高度可能大于页面高度，组件内部需要滚动条。
8. 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容。

**Q13 你觉得你做过的你觉得最值得炫耀的项目？**



**Q2 刚刚说的java调用js离线生成数据报告？java调用js的promise异步返回结果怎么实现的？**

使用java的js引擎Nashorn，Nashorn不支持事件队列，是要引进polyfill，然后java调用js方法获得java的promise对象，然后在调用该对象的then方法，回调函数为java中的某各类的某个方法，然后while一个表示是否已执行回调的变量，如果未执行，则让java主线程sleep，如果已经执行，则跳出循环，表示是否已执行回调的变量在传入promise的回调函数中设置更改。详情代码见地址

**Q3 说说svg和canvas各自的优缺点？**

共同点：都是有效的图形工具，对于数据较小的情况下，都很又高的性能，它们都使用 JavaScript 和 HTML；它们都遵守万维网联合会 (W3C) 标准。

svg优点：

- 矢量图，不依赖于像素，无限放大后不会失真。
- 以dom的形式表示，事件绑定由浏览器直接分发到节点上。

svg缺点：

- dom形式，涉及到动画时候需要更新dom，性能较低。

canvas优点：

- 定制型更强，可以绘制绘制自己想要的东西。
- 非dom结构形式，用JavaScript进行绘制，涉及到动画性能较高。

canvas缺点：

- 事件分发由canvas处理，绘制的内容的事件需要自己做处理。
- 依赖于像素，无法高效保真，画布较大时候性能较低。

**Q4 你刚刚说的canvas渲染较大画布的时候性能会较低？为什么？**

因为canvas依赖于像素，在绘制过程中是一个一个像素去绘制的，当画布足够大，像素点也就会足够多，那么想能就会足够低。

**Q6 假设我现在有5000个圆，完全绘制出来，点击某一个圆，该圆高亮，另外4999个圆设为半透明，分别说说用svg和canvas怎么实现？**

首先，从数据出发，我们的每个圆是一个数据，这个数据有圆的x、y、radius、isHighlight如果是svg，直接渲染节点即可，然后往节点上边绑定点击事件，点击改变所有数据的高亮属性（必须同步执行完成），然后让浏览器进行绘制。如果是canvas，我们需要自己绑定事件到canvans标签上，然后点击的时候判断点击的位置是否在圆内，如果在某个圆内，则更新所有数据的高亮属性，之后在进行一次性绘制。

**Q7 刚刚说的canvas的点击事件，怎么样实现？假如不是圆，这些图形是正方形、长方形、规则图形、不规则图形呢**

针对于每一个形状，将其抽象成shape类，每一个类有自己的方法isPointInSide来判断节点是否在图形内，对于不规则图形，当做矩形处理，点击的时候执行该方法判断点击位置是否在图形内。

**Q8 那假如我的图形可能有变形、放大、偏移、旋转的需求呢？你的这个isPointInSide怎么处理？**

这个我答不出来，据面试官提示，好像有相应的API处理变形、旋转、放大等等之后的位置映射关系。

**Q9 那个这个canvas的点击事件，点击的时候怎么样快速的从这5000个圆中找到你点击的那个圆（不完全遍历5000个节点）？**

可以通过预查找的形式，当鼠标划过的时候预先查找到鼠标附近的一些节点，当点击的时候在从这些预先筛选好的节点里查找点击下来的节点，当然这个方法的前提是不能影响js主线程的执行，必须是异步的形式。

**Q10 那你用过@antv/g6，里面有一个tree，说说你大学时候接触到的tree的数据结构是怎么实现的？**

毕业一年多，tree的结构大概忘记了，我当时是这么回答的：

大学使用的是C++学的数据结构，是用指针的形式，首先有一个根节点，根节点里有一个指针数组指向它的所有子节点，然后每一个子节点也是，拥有着子节点的指针数组，一层一层往下，直到为叶子节点，指针数组指向为空。

**Q11 还记得二叉树吗？描述二叉树的几种遍历方式？**

- 先序遍历：若二叉树非空，访问根结点，遍历左子树，遍历右子树。
- 中序遍历：若二叉树非空，遍历左子树；访问根结点；遍历右子树。
- 后序遍历：若二叉树非空，遍历左子树；遍历右子树；访问根结点。

所有遍历是以递归的形似，直到没有子节点。

**Q12 说说你记得的所有的排序，他们的原理是什么？**

- 冒泡排序：双层遍历，对比前后两个节点，如果满足条件，位置互换，直到遍历结束。
- 快速排序：去数组中间的那一个数，然后遍历所有数，小于该数的push到一个数组，大于该数的push到另外一个数组，然后递归去排序这两个数组，最后将所有结果连接起来。
- 选择排序：声明一个数组，每次去输入数组里面找数组中的最大值或者最小值，取出来后push到声明的数组中，直到输入数组为空。

**Q13 说一下你觉得你做过的最复杂的项目？中间遇到的困难，以及你是怎么解决的？**-

**面试官：我这边问题差不多问完了，你还有什么问题？**

我：很惊讶今天全都是问可视化相关的，没怎么问js，css，html。

面试官：那我们继续吧

我：。。。

**Q14 那给我介绍一下react吧（面试官是做可视化开发的，根本不懂react）**

以前我们没有jquery的时候，我们大概的流程是从后端通过ajax获取到数据然后使用jquery生成dom结果然后更新到页面当中，但是随着业务发展，我们的项目可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们又需要重新组装一次dom结构，然后更新页面，这样我们手动同步dom和数据的成本就越来越高，而且频繁的操作dom，也使我我们页面的性能慢慢的降低。

这个时候mvvm出现了，mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以大大降低我们手动去维护dom更新的成本，mvvm为react的特性之一，虽然react属于单项数据流，需要我们手动实现双向数据绑定。

有了mvvm还不够，因为如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了页面性能)的问题，为了解决这个问题，react内部实现了一套虚拟dom结构，也就是用js实现的一套dom结构，他的作用是讲真实dom在js中做一套缓存，每次有数据更改的时候，react内部先使用算法，也就是鼎鼎有名的diff算法对dom结构进行对比，找到那些我们需要新增、更新、删除的dom节点，然后一次性对真实DOM进行更新，这样就大大降低了操作dom的次数。

那么diff算法是怎么运作的呢，首先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且用新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对比这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。

react设计之初是主要负责UI层的渲染，虽然每个组件有自己的state，state表示组件的状态，当状态需要变化的时候，需要使用setState更新我们的组件，但是，我们想通过一个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到父组件当中，让父组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要一直往下传，无疑加大了我们代码的复杂度，我们需要一个状态管理中心，来帮我们管理我们状态state。

这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某一个state有变化的时候，依赖到这个state的组件就会进行一次重渲染，这样就解决了我们的我们需要一直把state往下传的问题。redux有action、reducer的概念，action为唯一修改state的来源，reducer为唯一确定state如何变化的入口，这使得redux的数据流非常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。

后来，社区就出现了另外一套解决方案，也就是mobx，它推崇代码简约易懂，只需要定义一个可观测的对象，然后哪个组价使用到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，而且mobx内部也做好了是否重渲染组件的生命周期shouldUpdateComponent，不建议开发者进行更改，这使得我们使用mobx开发项目的时候可以简单快速的完成很多功能，连redux的作者也推荐使用mobx进行项目开发。但是，随着项目的不断变大，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux。

**Q15 假如我一个组件有一个状态count为1，然后我在componentDidMount()里面执行执行了两次this.setState({count: this.state.count++})，然后又执行了两次setTimeout(() => { this.setState({count: this.state.count++}) }, 0)，最后count为多少？为什么？**

count为4，因为第二次执行setState的时候，取不到第一次this.state.count++的结果，react在一轮生命周期结束后才会更新内部的state，如果在一轮生命周期内多次使用了setState，react内部会有一个字段isBatchUpdate标识本次更新为批量更新，然后在最后render的时候将所有setState的结果提交到state中，一次性进行更新，并且把isBatchUpdate这个字段设置为false。

针对于两次setTimeout，js引擎会把这两个setState丢到事件队列中，等待js空闲了去执行，而我们的渲染函数render是同步执行的（react16版本默认没有开启异步渲染），所以等我们render执行完全，也就是我们的state被同步完后，在取事件队列里面的setState进行执行，setTimeout的第二个setState也是一样的，所以最后结果是4。



# 百度前端要求

先谈一谈这一年来我们的变化：

- 有了对外的业务，我们称之为“百度效率云”，为开发者提供代码托管、项目管理、CICD流水线、云原生开发的一站式解决方案。
- 随着对技术的探索，逐渐明晰并绘制了我们的技术全景图，框架包括UI、IO、路由、状态管理、组件增强，工具包括Lint、Build、Dev、Test，运行时包括各种小型在线服务，共同支撑着16+的产品线。
- 依旧保持着对最前沿技术的敏感与跟进，在不少产品线大范围地落地React Hooks、Suspense等开发模式，Webpack已经为5做好了准备。
- 开始逐渐接纳TypeScript，在小型的工具、产品项目中有了实际的使用。
- 有了全新的IDE方向，对VS Code进行深度定制，以VS Code Remote和Code Server为载体提供远程开发环境，团队自身已经深入地使用这一环境进行开发。

抛开死板的JD，真诚地说，我们希望你是：

- 有相对扎实的前端编程基础，JavaScript基本API、异步编程、常用布局等可以无障碍地应用。
- 熟悉状态驱动的视图开发，熟悉React和Redux的基本开发范式。
- 能理解历史遗留技术债，这在每一个长期活着的团队里都一定存在，我们一直在努力不断地削减债务，但不可能让每一行代码都崭新闪闪发亮。
- 对技术有热情，愿意与人争论来追求正确的结果，与团队一同保持成长。
- 务实，自驱，以目标作为参照来行动。



## 职位及地点

我们当前招聘Web前端工程师、高级Web前端工程师，入职地点为北京。

## 职责

- 参与完整的互联网研发工具链产品的研发工作，包括项目需求管理平台、源码管理平台、持续集成平台等多个产品，服务百度1W+工程师的日常。
- 探索优秀的工程标准，参与建设工程能力可视化、平台治理等系统，以公司为格局实现工程与服务的可评估、可分析、可共享、可管理。
- 追踪前端业界前沿架构、理念，投入前端通用模块、基础框架、开发工具的设计与开发，挖掘、优化、提升前端团队研发效率及质量。
- 整合公司各平台资源，建设面向公司级别的前端基础能力平台，如NPM依赖管理、Node持续构建环境、通用CDN内容分发系统等，为公司数千名前端提供一致、便携、高效的工具及平台。
- 关注用户体验，采集并分析PV、性能、行为等多类型用户数据，用真实数据反馈产品设计，通过良性循环持续提升产品整体体验。
- 作为工程师，通过日常使用自己研发的系统，发现相关功能、体验的问题，并在团队、部门的支持下进行修复或改进，不断优化整体产品及平台。
- 与产品、后端、测试、用户等多种角色互动，推进落实产品级、部门级的研发工程标准，如前后端通信规范、AB Test分流标准等。
- 与其他前端工程师进行配合研发，通过高标准的代码评审、设计评审等环节，保持代码质量的稳定可靠。

## 环境

- 以React及Redux为基础研发体系，通过自研关键点并整合社区的现有方案，具备一套完整的前端解决方案，包含数据流、状态管理、组件库、图标库、国际化、数据采集等，可快速上手。
- 团队拥有高度可复用的研发工具，包括用户模拟、代码检查、项目调试、系统构建等功能，可一键完成相关工作，无需深陷ESELint或Webpack等配置。
- 持续跟进新版本浏览器，淘汰超出年限的旧浏览器，浏览器兼容工作趋近于零，可大量使用浏览器最新标准及相关功能。
- 团队始终保持着对前端最前沿技术的敏锐嗅觉，持续不断地将最新的理念、设计等转化为实际可落地的技术方案，应用于产品中，并滚动式地改进现有应用，保持从技术选型到代码编写全过程的先进性。
- 团队对代码质量要求严格，拥有对质量和可维护性绝不妥协的信念。所有代码必须有同行进行评审，不定期进行架构、设计、代码的分享与讲解。
- 具备可执行的培训机制，包括入职后的基本技术能力培训、工作过程中导师1对1的辅导跟进，以及团队持续的分享与培训，也可通过提出主题来获得他人的分享。
- 部门层面认可工程能力建设的重要性及必要性，有大量资源投入于各种能力的建设上，对代码评审、持续集成、自动化检测等提升工程能力的工作给予认可和支持。

## 要求

- 会使用Git进行源码管理，理解Git的基本概念，熟悉至少一种主流的Git分支管理及工作流。
- 理解软件工程的基本概念，了解一个功能的研发生命周期，掌握基础的需求管理知识，接触过持续集成的概念和相关工具。
- 具体扎实的JavaScript、HTML、CSS知识，有Node使用经验者优先。
- 对异步有深刻的认识，熟悉基于`Promise`进行异步编程，熟悉并发异步的管理。
- 熟悉至少一个现代化View层框架（React、Vue、Angular）的使用经验，对组件、生命周期、DOM更新机制等有基本理解。
- 熟悉HTTP协议，了解HTTPS、HTTP/2、WebSocket等衍生概念。
- 对用户体验有持续的追求与坚持，理解交付用户最优秀的产品是第一职责，对产品的交互、视觉等体验积极思考并提出自己的建议。
- 具备良好的代码质量意识，理解高质量代码对系统的可维护性的重要性，能够通过代码评审保持团队代码质量，愿意通过不断的重构改进自身代码质量。
- 热爱前端，愿意跟随前端的快速发展，保持对前沿技术的热忱并积极投入探索和研究。
- 有状态管理框架（Redux、MobX、Vuex）使用经验，理解状态管理的关键要素、流程者优先。
- 熟悉浏览器工作原理者优先。
- 有函数式编程概念者优先。

## 联系方式

可将简历发送至：otakustay@gmail.com



## 百度-百度云（过）

这个部门今年据说升为一级部门了，好像还挺不错的

## 一面

1. 讲项目
2. vue响应式原理，什么是mvvm
3. es6使用过的特性
4. flex常见的属性
5. css选择器的优先级
6. 抽取过哪些vue组件

## 二面

1. 讲项目
2. express设计原理，面试官对动态路由匹配一直追问下去，但是这里的源码设计我确实是忘了，一路讨论下去扯到了字符串的前缀树...
3. 实现一个事件发布订阅类，其实就是eventEmitter

## 三面

三面是山大老学长，聊了一些业务上的事情