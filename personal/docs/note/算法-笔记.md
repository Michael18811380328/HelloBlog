# 算法笔记 
 
## 0005 DFS和BFS的区别


以二叉树为例，bfs和dfs的具体区别是什么？他们的性能有什么差距

DFS 使用函数递归调用实现

```
  runNode = (node) => {
    if (!node) return;
    fn(node.val);
    this.runNode(node.left);
    this.runNode(node.right);
  }

```

BFS 使用队列实现

```
  runNode = (node) => {
    let queue = [];
    queue.push(node);
    while (queue.length > 0) {
      let curr = queue.shift();
      fn(curr.val);
      queue.push(curr.left)
      queue.push(curr.right);
    }
  }

```

性能上都一样，一个按照深度节点遍历，一个优先按照层遍历。时间复杂度和空间复杂度差不多。



   
## 0006 DFS和BFS分别实现深拷贝一个对象


不考虑环形引用，那么就循环对象的键值对，然后分别拷贝即可



   
## 0017 两个数组的交集怎么计算


循环第一个数组，记录在字典中；循环第二个数组，然后把重复出现的拿出来返回



   
## 0036 使用递归迭代两种办法，实现数组flat函数


递归就是在一个函数内部调用这个函数

```
fn(node) {
	return fn(node.val)
}

```

迭代就是一个变量，等于某个函数执行这个变量后的结果

```
arr = fn(arr)

const fn = (arr) => {
    if (!arr.some(item => Array.isArray(item))) return arr;
	return [].concat(...arr);
}

```



   
## 0054 冒泡排序的时间复杂度是多少？还可以怎么改进


冒泡排序的时间复杂度是n^2，循环两次实现


改进方法就是用并归排序或者快速排序，时间复杂都是 nlogn



   
## 0059 两个数组的最长公共子序列怎么计算


最长公共子序列——动态规划，参考这里 <https://blog.csdn.net/hj7jay/article/details/79350978>  子序列不一定连续

最长公共子串，公共子串是连续的，直接循环子串即可满足



   
## 0067 把一个离散的数组变成子序列，连续的数组


数组都是整数，那么先排序，然后循环一下

设置一个start end 然后循环原始数组，如果是连续的，继续循环；如果不是连续的，设置 end 然后把子数组创建一个新的数组，放在原始数组中，最后就是二维的连续数组



   
## 0071 设计字符串匹配算法


算法要求：判断A字符串中是否有B字符串。如果有返回所在的位置。

思路1：使用 indexOf 字符串内置的方法实现

```
return str1.indexOf(str2)

```

思路2：循环字符串，然后依次比较子字符串是否相等

```
  checkStr = (str1, str2) => {
    let len = str2.length;
    for (let i = 0; i < str1.length; i++) {
      if (str1.slice(i, i + len) === str2) return true;
    }
    return false;
  }

```



   
## 0081 打印对称数


对称数：也就是回文数，就是数字转换成字符串，然后转换成数组，翻转后和原数字一样

这里就是循环 0-10000 然后判断每一个是否是回文数

数字-字符串-数组转换比较耗时，如果追求时间快速，那么直接循环字符串比较更快

```
  getNumber = () => {
    let result = [];
    for (let i = 1; i <= 10000; i++) {
      if (checkNumber(i)) {
        result.push(i);
      }
    }
    return result;
  }

  checkNumber = (n) => {
    return String(n).split('').reverse().join('') === String(n);
  }

```



   
## 0082 移动数组中的0到末尾


把一个数组中的0，全部移动到最后，需要原地算法

时间复杂度是N

```
  moveZero = (arr) => {
    let timer = 0;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === 0) {
        arr.splice(i, 1);
        arr.push(0);
        i--;
        timer++;
      }
      if (timer >= arr.length) {
        return arr;
      }
    }
    return arr;
  }

```

改进版

```
  moveZero = (arr) => {
    let timer = 0;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === 0) {
        arr.splice(i, 1);
        timer++;
        i--;
      }
    }
    for (let i = 0; i < timer; i++) {
      arr.push(0);
    }
    return arr;
  }

```



   
## 0085 两数之和


数组中，某两数之和是 sum 求这两个数的位置

1、入门思路，两层循环 N \* N

2、进阶思路，外层循环N，内层使用二分法循环，这个复杂度是 N \* logN 

对应的四数之和，三数之和也是类似的原理（当然时间复杂度就变化了）



   
## 0087 把一个部门的 array 转换成部门的 tree 结构


先假设全部的数据都是正确的，只有一个根节点，不存在部门互相引用（不是图，不需要标记）

每一个部门有 parent_dep 和 child_dep 父节点和子节点

1、首先把数组循环一次，关系存放在对象中，保存父节点和子节点的对象，并找到根节点

2、把根节点找到，然后新建树的根节点，然后获取子节点，DFS 找到子部门

3、最后返回整个树节点 



   
## 0093 找出一个有序数组的中位数


二分法查找中位数



   
## 0099 输入整数，输出一个反转后的字符串


数字转换成字符串，字符串分割成数组，数组反转，合并成字符串



   
## 0215 有序链表转换成二叉搜索树


题目109

有序链表转换成二叉搜索树

目前做法是先把有序链表转换成有序数组，然后转换成二叉搜索树。官方的思路是：使用快慢指针，获取有序链表的中点，然后左右分别作为开始和结束，转换成子树作为树节点。关键是记录开始节点和结束节点的位置（链表中记录位置的方案）



   
## 0216 锯齿状层序遍历二叉树


题目103

锯齿状层序遍历二叉树（先把二叉树普通层序遍历，然后加一个层序号属性；然后把列表根据层序号再转换成二维数组即可）时间复杂度是O(n) 遍历全部树节点，然后遍历一下临时的一维列表。空间复杂度是多出的一个临时数组存放节点的值和层数。



   
## 0217 二叉树展开为链表


题目114

二叉树展开为链表

先把二叉树先序遍历成数组，然后遍历数组，给数组的每一个元素增加引用，实现单链表 



   
## 0218 原地算法


不使用额外的堆内存空间（可以使用临时变量）使用：倒转数组；判断回文



   
## 0219 笛卡尔积


数学中，两个集合的乘积，叫做笛卡尔积

拼音中，A 集合是声母的集合，B集合是韵母的集合，那么 A 和 B 的笛卡尔积就是全部读音的集合（不考虑特殊情况）



可以是 N 个集合的笛卡尔积



运算规则：不符合交换律和结合律，求并集和交集满足分配率



详情参考：https\://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AF

```
举例：集合 A = {1, 2}, B = {a, b, c};
笛卡尔积 A x B = {(1, a), (1, b), (1, c), (2, a), (2, b), (2, c)}
笛卡尔积 B x A = {(a, 1), (a, 2), (b, 1), (b, 2), (c, 1), (c, 2)}

```



   
## 0220 最小花费爬楼梯


最小花费爬楼梯：这是经典DP算法，最小花费，也就是爬上一个楼梯，还是跳过一个，也就是可以转换成递推公式 \`Fn = min(Fn-2 + An-2, Fn-1 + An-1)\`，

这样就可以算出最的花费（类似最小花费买卖股票）。

注意细节：开始的前两个可以直接跳过，所以 F0 = F1 = 0。然后爬上去，最后需要计算 Fn 的结果，爬到楼梯顶端。



  