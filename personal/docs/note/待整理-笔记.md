# 待整理笔记 
 
## 0202 基础面试题目


如果是第一轮的笔试，这是必须会背过的部分

手写

1.节流，防抖。

2.冒泡排序，快速排序——要求直接写出来

```javascript
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    for (let j = i; j < len; j++) {
      // compare arr[i] and arr[j] and change their position
      if (arr[i] > arr[j]) {
        let tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
    }
  }
  return arr;
}

function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  let left = [];
  let right = [];
  let tmp = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > tmp) {
      right.push(arr[i]);
    } else {
      left.push(arr[i]);
    }
  }
  return quickSort(left).concat(tmp).concat(quickSort(right));
}

```

3.定位都有哪些

4promise用法

5.es6的用法

6.redux

7.sass用过了什么。



   
## 0215 0109. 有序链表转换成二叉搜索树


题目109

有序链表转换成二叉搜索树

目前做法是先把有序链表转换成有序数组，然后转换成二叉搜索树。

官方的思路是：使用快慢指针，获取有序链表的中点，然后左右分别作为开始和结束，转换成子树作为树节点。关键是记录开始节点和结束节点的位置（链表中记录位置的方案）

二叉搜索树的核心：就是找到中位数作为根节点

1、可以使用快慢指针，获取排序链表的中位数。当快指针到达最后一位时，慢指针正好是中位数

2、设置中位数的是根节点，然后左子树和右子树的边界

可以确定，递归左右子树即可注意：链表找到元素的索引

```javascript
const sortedListToBST = function(head) {
  // 先把有序列表转换成有序数组
  const arr = [];
  while (head) {
    arr.push(head.val);
    head = head.next;
  }
  // 然后把有序数组转换成二叉搜索树
  function arr2Tree(start, end) {
    if (start > end) {
      return null;
    } else if (start === end) {
      return new TreeNode(arr[start]);
    } else {
      const middle = Math.floor((start + end) / 2);
      const node = new TreeNode(arr[middle]);
      node.left = arr2Tree(start, middle - 1);
      node.right = arr2Tree(middle + 1, end);
      return node;
    }
  }
  return arr2Tree(0, arr.length - 1);
};

```



   
## 0216 0103. 二叉树的锯齿形层序遍历


题目 0103 难度简单，认真一次性可以做出来

锯齿状层序遍历二叉树（先把二叉树 BFS 层序遍历，然后加一个层序号属性；然后把列表根据层序号再转换成二维数组即可）

时间复杂度是O(n) 遍历全部树节点，然后遍历一下临时的一维列表。

空间复杂度是多出的一个临时数组存放节点的值和层数。

```javascript
const zigzagLevelOrder = function(root) {
  if (!root) return [];
  // 先把二叉树层序遍历(广度优先遍历)，同时增加layer层数
  const res = [];
  const list = [];
  list.push({
    node: root,
    layer: 0,
  });
  while (list.length > 0) {
    const tmp = list.shift();
    res.push({ val: tmp.node.val, layer: tmp.layer });
    const layer = tmp.layer;
    const left = tmp.node.left;
    const right = tmp.node.right;
    if (left) {
      list.push({ node: left, layer: layer + 1 });
    }
    if (right) {
      list.push({ node: right, layer: layer + 1 });
    }
  }
  // 再次遍历数组，把每一层的结果都放入临时数组，然后返回
  const result = [];
  let flagLayer = 0;
  let tmpArr = [];
  for (let i = 0; i < res.length; i++) {
    const { layer, val } = res[i];
    if (layer === flagLayer) {
      tmpArr.push(val);
    } else {
      // 这里需要根据层数，决定是否取反
      if (flagLayer % 2 === 0) {
        result.push([...tmpArr]);
      } else {
        result.push([...tmpArr].reverse());
      }
      tmpArr = [];
      tmpArr.push(val);
      flagLayer = layer;
    }
  }
  // 最后还需要处理一层
  if (flagLayer % 2 === 0) {
    result.push([...tmpArr]);
  } else {
    result.push([...tmpArr].reverse());
  }
  return result;
};

```



   
## 0217 0114. 二叉树展开为链表


题目114 简单

二叉树展开为链表

先把二叉树先序遍历成数组，然后遍历数组，给数组的每一个元素增加引用，实现单链表 



   
## 0236 0098. 验证二叉搜索树


98 验证二叉搜索树

二叉搜索树的性质是，节点值大于左子树最大值，节点值小于右子树最小值。

思路一：使用递归方法，先构建一个递归函数 checkTree(node, small, large)，判断每一个子树的最大最小值。只需要判断当前节点，在递归中判断子节点即可. 

思路二：二叉搜索树的中序遍历结果，是一个升序数组，那么根据这个性质，遍历二叉树。如果不是升序数组，就不是二叉搜索树。



   
## 0237 0097. 交错字符串


97 交错字符串：

思路一，使用DFS递归字符串，并先判断是否全部字符的个数相同，这样可以实现，性能比较差。

思路二：使用动态规划，从开头一直递推到最后的一个值。

思路三：回溯算法+三指针+字典记忆化 



   
## 0238 0152. 最大乘积子数组


最大乘积子数组：动态规划思路，和最大和子数组类似。Fx = F(x-1) 的递推式。如果全部是正数，那么完全一致。如果有正数有负数，当前的最大值，可能是前面的最小值和当前值的乘积，所以需要维护两个数组，分别存放最大值和最小值的递推式。



   
## 0239 0095. 不同的二叉搜索树


95 不同的二叉搜索树（以1-N为节点，可以建立多少个不同的二叉搜索树？）

问题关键是：二叉搜索树左子树小于当前节点，右子树大于当前节点。那么遍历1-N作为根节点，然后设置 1——1-i是左子树，i+1 —— n 是右子树，然后递归遍历子树的情况。最后把左右子树双重循环即可找到全部的结果。注意：如果一个位置是空的，也需要返回 Null 节点。



   
## 0241 二叉树


二叉树是经典的题目，也是前端经常使用的数据结构，主要习题如下

116 完美二叉树中，填充每个节点的next指针，下一个右侧节点。实际上就是先把二叉树层序遍历成矩阵，然后遍历每一个子数组，设置指针指向下一个节点即可。

199 二叉树的右视图：先把二叉树层序遍历，然后获取每一层的最后一个元素即可

105 从前序遍历和中序遍历数组中（无重复元素），恢复二叉树.找到根元素和左右子树，然后递归即可

106 从中序遍历和后续遍历中恢复二叉树（类似105）



   
## 0242 0166. 分数到小数


166 分数到小数（需要细心）

关键点：

1、两个整数相除，结果可能是整数，小数，或者循环小数。不可能是无限不循环小数，这个是数学原理。

2、如何判断是循环小数？每次计算，如果余数出现相同，那么就是循环小数，所以适应一个对象记录出现的余数，使用一个数组记录出现的位置，即可把循环的部分获取到。 



   
## 0244 0164. 最大间距


最大间距：常规的思路：数组快速排序，然后循环一次，获取最大间距（快速排序是N\*logN）。

因为题目要求是N，这个方法严格上不合适。

官方给出的思路是基数排序或者桶排序。实际中直接使用内置的排序即可。



   
## 0343 nodejs的异步IO是什么？


类似 ajax 请求，IO 操作（读写文件）比较耗时。

所以类似 ajax 异步操作，IO 操作也可以异步实现，在回调函数中处理逻辑。服务器中，处理运算，处理读写文件可以异步执行，避免某个 IO 操作耗时过长，阻塞其他的任务执行。

同步写法

```javascript
const fs = require('fs');

const data = fs.readFileSync('./file.js');

console.log(data)

```

```javascript
const fs = require('fs')

fs.readFile('./file.js',(err,data)=>{
    console.log(err,data) // null
    // <Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 68 77 6f 72 6c 64 27 29>
})

console.log(111) // 111

```

参考：<https://juejin.cn/post/7002106372200333319> 

相关知识还有：事件循环，线程池等，这部分目前实际项目没用上，了解概念即可。



   
## 0345 前端加密算法有哪些？


#### 为什么进行前端加密

在 http 协议下，数据是明文传输，传输过程中网络嗅探，可直接获取其中的数据，如用户的密码和信用卡相关的资料，一旦被中间人获取，会给用户带来极大的安全隐患。另一方面在非加密的传输过程中，攻击者可更改数据或插入恶意的代码等。

前端加密的意义: 即在数据发送前将数据进行哈希或使用公钥加密。如果数据被中间人获取，拿到的则不再是明文。

当然还有其他一些优点，例如避免后端等打印日志直接暴露明文密码，还可以避免明文撞库等。

#### 加密方法

* 常见对称加密有AES、DES、3DES等，常用AES实现。
* 常见非对称加密有RSA、ECC等，常用RSA实现（公钥私钥，例如 github 登录）。

#### 案例

crypto-js 实现前端对称加密，后端收到消息后解密。

md5

sha256

#### 数据库加密

数据库存储用户名的密码时，加盐操作

#### 参考链接

<https://zhuanlan.zhihu.com/p/480875682> 

<https://blog.csdn.net/w418856/article/details/130964706> 



  