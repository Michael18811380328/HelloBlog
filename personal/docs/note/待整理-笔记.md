# 待整理笔记 
 
## 0215 0109. 有序链表转换成二叉搜索树


题目109

有序链表转换成二叉搜索树

目前做法是先把有序链表转换成有序数组，然后转换成二叉搜索树。

官方的思路是：使用快慢指针，获取有序链表的中点，然后左右分别作为开始和结束，转换成子树作为树节点。关键是记录开始节点和结束节点的位置（链表中记录位置的方案）

二叉搜索树的核心：就是找到中位数作为根节点

1、可以使用快慢指针，获取排序链表的中位数。当快指针到达最后一位时，慢指针正好是中位数

2、设置中位数的是根节点，然后左子树和右子树的边界

可以确定，递归左右子树即可注意：链表找到元素的索引

```javascript
const sortedListToBST = function(head) {
  // 先把有序列表转换成有序数组
  const arr = [];
  while (head) {
    arr.push(head.val);
    head = head.next;
  }
  // 然后把有序数组转换成二叉搜索树
  function arr2Tree(start, end) {
    if (start > end) {
      return null;
    } else if (start === end) {
      return new TreeNode(arr[start]);
    } else {
      const middle = Math.floor((start + end) / 2);
      const node = new TreeNode(arr[middle]);
      node.left = arr2Tree(start, middle - 1);
      node.right = arr2Tree(middle + 1, end);
      return node;
    }
  }
  return arr2Tree(0, arr.length - 1);
};

```



   
## 0216 0103. 二叉树的锯齿形层序遍历


题目 0103 难度简单，认真一次性可以做出来

锯齿状层序遍历二叉树（先把二叉树 BFS 层序遍历，然后加一个层序号属性；然后把列表根据层序号再转换成二维数组即可）

时间复杂度是O(n) 遍历全部树节点，然后遍历一下临时的一维列表。

空间复杂度是多出的一个临时数组存放节点的值和层数。

```javascript
const zigzagLevelOrder = function(root) {
  if (!root) return [];
  // 先把二叉树层序遍历(广度优先遍历)，同时增加layer层数
  const res = [];
  const list = [];
  list.push({
    node: root,
    layer: 0,
  });
  while (list.length > 0) {
    const tmp = list.shift();
    res.push({ val: tmp.node.val, layer: tmp.layer });
    const layer = tmp.layer;
    const left = tmp.node.left;
    const right = tmp.node.right;
    if (left) {
      list.push({ node: left, layer: layer + 1 });
    }
    if (right) {
      list.push({ node: right, layer: layer + 1 });
    }
  }
  // 再次遍历数组，把每一层的结果都放入临时数组，然后返回
  const result = [];
  let flagLayer = 0;
  let tmpArr = [];
  for (let i = 0; i < res.length; i++) {
    const { layer, val } = res[i];
    if (layer === flagLayer) {
      tmpArr.push(val);
    } else {
      // 这里需要根据层数，决定是否取反
      if (flagLayer % 2 === 0) {
        result.push([...tmpArr]);
      } else {
        result.push([...tmpArr].reverse());
      }
      tmpArr = [];
      tmpArr.push(val);
      flagLayer = layer;
    }
  }
  // 最后还需要处理一层
  if (flagLayer % 2 === 0) {
    result.push([...tmpArr]);
  } else {
    result.push([...tmpArr].reverse());
  }
  return result;
};

```



   
## 0217 0114. 二叉树展开为链表


题目114 简单

二叉树展开为链表

先把二叉树先序遍历成数组，然后遍历数组，给数组的每一个元素增加引用，实现单链表 



   
## 0236 0098. 验证二叉搜索树


98 验证二叉搜索树

二叉搜索树的性质是，节点值大于左子树最大值，节点值小于右子树最小值。

思路一：使用递归方法，先构建一个递归函数 checkTree(node, small, large)，判断每一个子树的最大最小值。只需要判断当前节点，在递归中判断子节点即可. 

思路二：二叉搜索树的中序遍历结果，是一个升序数组，那么根据这个性质，遍历二叉树。如果不是升序数组，就不是二叉搜索树。



   
## 0237 0097. 交错字符串


97 交错字符串：

思路一，使用DFS递归字符串，并先判断是否全部字符的个数相同，这样可以实现，性能比较差。

思路二：使用动态规划，从开头一直递推到最后的一个值。

思路三：回溯算法+三指针+字典记忆化 



   
## 0238 0152. 最大乘积子数组


最大乘积子数组：动态规划思路，和最大和子数组类似。Fx = F(x-1) 的递推式。如果全部是正数，那么完全一致。如果有正数有负数，当前的最大值，可能是前面的最小值和当前值的乘积，所以需要维护两个数组，分别存放最大值和最小值的递推式。



   
## 0239 0095. 不同的二叉搜索树


95 不同的二叉搜索树（以1-N为节点，可以建立多少个不同的二叉搜索树？）

问题关键是：二叉搜索树左子树小于当前节点，右子树大于当前节点。那么遍历1-N作为根节点，然后设置 1——1-i是左子树，i+1 —— n 是右子树，然后递归遍历子树的情况。最后把左右子树双重循环即可找到全部的结果。注意：如果一个位置是空的，也需要返回 Null 节点。



   
## 0241 二叉树


二叉树是经典的题目，也是前端经常使用的数据结构，主要习题如下

116 完美二叉树中，填充每个节点的next指针，下一个右侧节点。实际上就是先把二叉树层序遍历成矩阵，然后遍历每一个子数组，设置指针指向下一个节点即可。

199 二叉树的右视图：先把二叉树层序遍历，然后获取每一层的最后一个元素即可

105 从前序遍历和中序遍历数组中（无重复元素），恢复二叉树.找到根元素和左右子树，然后递归即可

106 从中序遍历和后续遍历中恢复二叉树（类似105）



   
## 0242 0166. 分数到小数


166 分数到小数（需要细心）

关键点：

1、两个整数相除，结果可能是整数，小数，或者循环小数。不可能是无限不循环小数，这个是数学原理。

2、如何判断是循环小数？每次计算，如果余数出现相同，那么就是循环小数，所以适应一个对象记录出现的余数，使用一个数组记录出现的位置，即可把循环的部分获取到。 



   
## 0244 0164. 最大间距


最大间距：常规的思路：数组快速排序，然后循环一次，获取最大间距（快速排序是N\*logN）。

因为题目要求是N，这个方法严格上不合适。

官方给出的思路是基数排序或者桶排序。实际中直接使用内置的排序即可。



   
## 0295 前端如何进行 SEO 优化


需要完善

编译成功后，上线后，在各大搜索引擎上面增加网站收录等

<https://blog.csdn.net/yuyuking/article/details/89374794> 



   
## 0296 MYSQL 性能问题


需要查

MYSQL 性能问题：如果并行请求很多，mysql 锁无法合理分配资源，产生延时。

解决方法：使用 mamcache 作为中间层



   
## 0297 python reload 函数


reload 函数

作用：重新载入之前载入的模块

参考链接：<https://www.runoob.com/python/python-func-reload.html> 

不同版本下使用不同，最新的 3.4 版本的语法，实际案例

```python
# 重新载入 sys 模块

import sys

import importlib

importlib.reload(sys)

```



  