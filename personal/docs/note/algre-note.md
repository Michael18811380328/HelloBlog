## 算法笔记

### 2023-08

无重叠区间：可以使用贪心算法，或者DP算法。因为区间的顺序可以变化，那么就优先使用贪心算法。可以先按照右侧区间排序，然后循环数组。如果前一项和后一项没有交集（也就是前一项的右侧区间 <= 后一项的左侧区间，那么这一项就是不重复区间，可以保留。如果重复，那么这一项就需要去掉）

### 1 双指针算法

使用条件：有序数组（无序数组先排序）。

分类：快慢指针和对撞指针。对撞指针用于小船载人问题；快慢指针用于判断链表中是否有环，排序数组去重操作等。

判断链表中是否有环，也可以使用对象唯一性判断；

排序数组去重操作，可以使用一次循环，然后splice操作；或者使用对象唯一性操作；或者使用 set 操作（后两种较复杂，适应于无序数组的去重）。两数之和、两数乘积之和，回文字符串等都可以使用双指针算法。

数组中指针用法：for循环数组，一个是当前的i，设置另一个指针pointer，这样可以指向不同的数组，进行处理

#### 快慢指针

~~~js
// 需要预处理next下一个节点是否存在等
let a = head.next;
let b = head.next.next;
while (a.next) {
  a = a.next;
  b = b.next.next;
}
~~~

#### 对撞指针

在一个排序数组中，找到两个数字，使得其中的和等于 target

~~~js
// 输入: numbers = [2, 7, 11, 15], target = 9
// 输出: [1,2]
let fn = (numbers, target) => {
	let left = 0;
	let right = numbers.length - 1;
	while (left < right) {
		let tmp = numbers[left] + numbers[right];
		if (tmp === target) {
			return [left, right];
		}
		if (tmp < target) {
			left++;
		}
		if (tmp > target) {
			right--;
		}
	}
	// 不满足的情况下，返回 null
	return null;
}

console.log(fn([2, 7, 11, 15], 9));
console.log(fn([2, 7, 10, 11, 15], 21));
~~~

### 2 有序数组转换成等高的二叉搜索树

等高的二叉搜索树，那么根节点必然是数组中中位数。数组已经排序，那么使用递归的思路直接将排序的有序数组转换成二叉搜索树，基本思路如下：

~~~js
function transArrayToBST (arr) {
  // 辅助函数
  const trans = (start, end) => {
    if (start > end) {
      return null;
    }
    if (start === end) {
      return new TreeNode(arr[start]);
    }
    // start < end 递归
    let mid = Math.floor((start + end) / 2);
    const midNode = new TreeNode(arr[mid]);
    midNode.left = trans(start, mid - 1);
    midNode.right = trans(mid + 1, end);
    return midNode;
  }
  return trans(0, arr.length - 1);
}
~~~

### 无向图的习题(中等+困难)

1、完全平方数：判断一个数 N 能被多少个完全平方数表示 例如 8 = 4 + 4 最少就是2个。

思路：先设置一个队列 queue = [], queue.push([n, 0])，当队列长度大于1时，从队列第一个拿出来，然后循环 for i= 0； i < item; i++ 然后判断结果是否满足，然后继续循环。如果结果恰好是0，那么完成递归，返回最小的个数即可。优化：如果队列中已经有K这个数字，那么不需要再次push，如果N很大，这样时间太差了（使用一个 MAP 记录已经存入的数字，再次push前判断即可）。

https://github.com/Michael18811380328/LeetCode/commit/eaceede8c35e9c92019391c18c2d9a318bda2b89#diff-0d424506e331420140e047a67d11a38d28c481d4645c5c4fb5ecd4bd1046c43c

2、单词最短路径 给定输入和输入单词 input output 还有一个单词列表，每次转换一个单词，判断最少多少次能够转换完成。

思路：先优化一下字典，把原来的单词去掉（如果存在）

辅助函数：判断两个单词是否只有一个字母不同

把开始的单词放在队列中，当队列的长度大于0，把队列中当期的元素拿出来，然后循环单词列表，如果有满足的单词（只有一个字母不同）把这个单词继续放在临时队列中。循环一次队列后，然后次数加1，把临时队列中全部的新单词，放在原始队列中。

循环结束条件：如果某个单词等于结果单词，那么就结束。如果最后没有相邻的单词，那么返回0。优化：在单词放入前，先记录到map中，避免两个单词互相为相邻单词，造成死循环问题。

https://github.com/Michael18811380328/LeetCode/commit/eaceede8c35e9c92019391c18c2d9a318bda2b89#diff-6b11e7950a42293fd05aa8fb0a0d3c22e0064f96bd7b8bdde504c09df544b652


164 最大间距：常规的思路：数组快速排序，然后循环一次，获取最大间距（快速排序是N*logN）。因为题目要求是N，这个方法严格上不合适。官方给出的思路是基数排序或者桶排序。实际中直接使用内置的排序即可。

188 买卖股票的最佳时机，关键是状态转移方程（没看懂，需要多个状态方程） 其他的刷了两道简单题目（数组排序等， 2144， 2148）

143 链表转换：常规的思路是，因为不能直接获取链表的长度，先把链表转换成数组，这样可以获取到不同节点的索引，以及总长度，然后使用双指针，把链表从开头和结尾加入，重新构建新链表）高级思路：先用快慢指针获取链表的中间节点，把链表分成两个子链表，然后把后面的链表反转，把两个链表合并即可。

194 bash 脚本处理文件内部字符串的转置。

166 分数到小数（需要细心）：关键点：1、两个整数相除，结果可能是整数，小数，或者循环小数，不可能是无限不循环小数，这个是常理。2、如何判断是循环小数？每次计算，如果余数出现相同，那么就是循环小数，所以适应一个对象记录出现的余数，使用一个数组记录出现的位置，即可把循环的部分获取到。 


### 2022-04-08

116 完美二叉树中，填充每个节点的next指针，下一个右侧节点。实际上就是先把二叉树层序遍历成矩阵，然后遍历每一个子数组，设置指针指向下一个节点即可。

199 二叉树的右视图：先把二叉树层序遍历，然后获取每一层的最后一个元素即可

105 从前序遍历和中序遍历数组中（无重复元素），恢复二叉树.找到根元素和左右子树，然后递归即可

106 从中序遍历和后续遍历中恢复二叉树（类似105）

### 2022-04-05

98 验证二叉搜索树：二叉搜索树的性质是，节点值大于左子树最大值，节点值小于右子树最小值。思路一：使用递归方法，先构建一个递归函数 checkTree(node, small, large)，判断每一个子树的最大最小值。只需要判断当前节点，在递归中判断子节点即可. 思路二：二叉搜索树的中序遍历结果，是一个升序数组，那么根据这个性质，遍历二叉树。如果不是升序数组，就不是二叉搜索树。

97 交错字符串：思路一，使用DFS递归字符串，并先判断是否全部字符的个数相同，这样可以实现，性能比较差。思路二：使用动态规划，从开头一直递推到最后的一个值。思路三：回溯算法+三指针+字典记忆化 

193 使用 bash 命令验证有效的电话号码，自己应该可以使用 js 正则表达式验证电话号码) 

152 最大乘积子数组：动态规划思路，和最大和子数组类似。Fx = F(x-1) 的递推式。如果全部是正数，那么完全一致。如果有正数有负数，当前的最大值，可能是前面的最小值和当前值的乘积，所以需要维护两个数组，分别存放最大值和最小值的递推式。

95 不同的二叉搜索树（以1-N为节点，可以建立多少个不同的二叉搜索树？）问题关键是：二叉搜索树左子树小于当前节点，右子树大于当前节点。那么遍历1-N作为根节点，然后设置 1——1-i是左子树，i+1 —— n 是右子树，然后递归遍历子树的情况。最后把左右子树双重循环即可找到全部的结果。注意：如果一个位置是空的，也需要返回 Null 节点。



### 3 回溯算法小结

核心代码：循环数组，然后把当前项一次放到临时数组中，然后判断临时数组是否满足条件。如果满足条件，直接放到结果数组中。如果不满足条件，如果没有达到条件，那么进一步回溯。如果超过条件，那么返回，继续循环下一个条件。

~~~js
if (tmp.length > K || sum(tmp) > K) {
 	let item = [...tmp];
  list.push(item);
  return;
}

for (let i = start; i < end; i++) {
  tmp.push(arr[i]);
  backtrack(tmp, list);
  tmp.pop(arr[i]);
}
~~~

注意点：目标数组中使用允许重复，全部样本中是否有重复的对象。

备注：如果要求全部样本中没有重复的对象，尽量避免使用 array.includes 判断 tmp 中是否存在另一个元素，这样算法复杂度较差。最好使用对象索引判断一下，减少复杂度。

应用：大部分排列组合问题、硬币找零问题（不能使用贪心算法）



### 4 动态规划小结（初级）

核心代码：当前的结果可以使用前面的结果表示。那么获取初始状态，以及获取递推公式，然后执行一次循环，即可算出N次结果的值。

~~~js
f(n) = F(a * f(n - 1) + b * f(n - 2) +);
~~~

动态规划的实质是，把一个实际问题，转换成数学的递推公式（通项公式），然后使用排列组合或者递推的方式计算结果。

应用：斐波那契函数、打家劫舍问题，背包问题，复杂排列组合问题

难点：把一个实际问题，转换成数学的递推公式

例子：排列组合数据量较大时，回溯方法内存溢出，使用DP解决

~~~js
var fn = (nums, target) => {
  nums.sort((a, b) => b - a);
  let dp = [];
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 1; i <= target; i++) {
    let tmp = 0;
    // 这里可以优化
    nums.forEach(num => {
      if (i - num >= 0) {
        tmp += dp[i - num];
      }
    });
    dp [i] = tmp;
  }
  return dp[target];
}
~~~

动态规划处理最大子序和（给定一个数组，求最大自序和）

1. 一个数组最大的自序和，那么等于每一个项结尾的自序和的最大值

maxList = [max1, max2, max3,,, maxn];
Math.max(...maxList)

2. 每一个项为结尾的最大自序和，可能是当前的 nums[i] 或者是 f(n - 1) + nums[i]

~~~js
function fn(nums) {
  let tmp = 0;
  let maxList = [];
  for (let i = 0; i < nums.length; i++) {
    tmp = Math.max(tmp + nums[i], nums[i]);
    maxList.push(tmp);
  }
  return Math.max(...maxList);
}
~~~




### 6 拼图算法和思路

如何用算法完成一个10000块的拼图？

1、复杂问题简单化：100块拼图，规范的拼图，没有重复的拼图，存储不限制，时间不限制

2、解决简单的问题

思路1：BFS 或者 DFS 算法

给出全部的拼图数组 arr，每一项是一个对象。对象的 ID 是某一块的唯一标识。四个边是某个属性值，全部拼图只有另一个和某一个完全一样

~~~js
let arr = [
  {
    id: '',
    left: '',
    right: '',
    top: '',
    bottom: '',
  }
];
~~~

关键是从某一个节点开始，然后获取相邻的节点（单项指针，或者对象的唯一键值对）。

把全部的节点遍历一次，存放在对象中。对象的键是属性，值是 ID。

~~~js
let dict = [];
for (let i = 0; i < arr.length; i++) {
  let { left, right, top, bottom, id } = arr[i];
  // 把这些属性全部存放到字典中(先假设属性都不同)
  dict[left] = id;
  dict[right] = id;
}
~~~

然后任意选择一个节点，DFS 获取邻接节点

~~~js
let init = arr[0];
let res = [];
res.push(init);
while(res[res.length - 1].right) {
  let next = dict[res[res.length - 1].right];
  if (next) {
    res.push(next);
  }
}
console.log(res);
// 先把一行拼出来
// 然后继续遍历其他几个方向
~~~

这个方法可以解决问题。因为已经在字典中存放了属性值，那么查找的速度比较快，时间复杂度可以接受。

实际我们拼图时，人脑不会采用这样的思路

因为遍历全部的节点需要时间，短时间内不能记住全部的节点属性，从一个点，找到四个相邻节点比较困难。

那么可以采用下面的算法改进

思路2：聚类算法

实际拼图时，往往先根据拼图上的一些特点（颜色相同，某些曲线相同，都含有某个图案，是否是边界点等特点），进行人脑聚类处理。

~~~js
let arr = [
  {
    id: '',
    color: 'red' | 'blue' | 'green' | null,
    graph: 'line' || 'circle' | null,
    is_icon: boolean,
    is_boundary: boolean,
  }
];
~~~

我们假设相邻的图片相似度很高，然后可以用聚类的算法，把全部图案分成若干群，每一个群组内部根据取值直接拼接，最后组合成较大的部分。可能有一些边缘的极端值，最后处理，这个符合人脑的思路

归纳：解决问题的思路

1、把复杂的问题简单化（10000的拼图，简化成100个，数量级的简化；四边凹凸不平的拼图，简化成规范的拼图，难度的简化；可能重复的拼图，简化成完全无重复的拼图，极端值边界值的简化；拼图是2维的，可以简化成1维的链表排序或者节点排序）

2、解决这个简单的问题（核心拼图算法）；或者拆成多个步骤解决；或者递推解决

3、把简答的解法复杂化（考虑数量级，考虑内存，考虑多维数据，考虑特殊值极端值影响）



### 7 获取字符串数组中，不重复字符串长度的最大值

基本算法是字符串算法，进阶算法是位运算，关键是判断两个字符串是否有相同的字母

1、先把字符串数组转换成对象数组，对象包括字符串的长度，字符串本身

2、双层循环这个对象数组，把每一个组合拿出来，作为新的数组（每一项是对象，包括长度的乘积，两个子字符串）

3、这个数组根据长度的乘积排序

4、循环数组，如果两个字符串没有公共字母，那么直接返回。如果有，继续下一个

判断两个字符串是否有公共的字母？

先把字符串遍历一次，获取字典。然后遍历这两个字典的 key 如果有重复，就是有公共的字母。

可以做一个临时变量 dict: {} key 是字符串，value 是字典，这样可以减少计算字符串的字符的数量。



### 8 滑动窗口双端队列（求滑动窗口的最大值-最小值）

数据结构：一个滑动窗口数组存放数组下标，一个结果数组

算法：循环数组，将窗口外部的下标去掉，将窗口中小于当前数字的项去掉，然后把当前的数组的项放进去，这样始终保证窗口第一项对应的数组的值是最大的。当滑动到窗口区间时，把窗口的数字放入结果数组中。



### 10 二分算法

二分，判断，然后递归或者while循环；

二分前提是排序的数组；确定二分的边界和最终值，避免死循环；

二分算法可以用来快速查找数组中是否有指定元素；或者快速排序法（选择数组中第一个元素作为根元素，然后定义两个空数组，分别存放比根元素大的元素和小的元素，然后遍历数组剩下的项和根元素对比，当道两个空数组中，然后把大数组，根元素，小数组合并起来即可）大数组和小数组继续执行二分法排序。



### 11 贪心算法

主要用于可以把问题逐步分解的情况，贪心算法可能不是最好的办法，所以需要考虑是否适合使用贪心算法。主要可以解决的问题是背包问题（重量有限，尽量装价值最多的商品）那么可以计算不同产品的价格重量比值，然后存放不同的商品。或者硬币找零问题等等。



### 12 二叉树的层序遍历

1、基本二叉树的层序遍历：使用BFS遍历，设置临时队列，每次循环临时队列，放置每一层的元素。

2、二叉树的锯齿层序遍历：遍历一层后，如果是奇数或者偶数，然后把结果数组 reverse 一下

3、二叉图的左视图右视图：BFS遍历每一层，获取每一层的第一个节点的 value 即可（使用DFS比较复杂）
