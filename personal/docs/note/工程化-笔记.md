# 工程化笔记 
 
## 0020 npm 模块安装机制是什么？npm install 原理


这个就是依赖树的问题

1 读取 package.json 文件，解析出 dependencies 和 devDependencies 中全部的依赖文件，这是一个列表

2 循环数组，下载对应的依赖包，然后遍历依赖的依赖，如果没有下载，那么下载并放在数组中

3 直到数组中的依赖被全部下载完成

如果有两个库依赖的第三方库版本不一致，可能造成冲突，例如一个依赖 react16 另一个依赖 React18 这样就会报错。解决办法是 force 或者改成一样的依赖版本



   
## 0026 模块化的发展历程


早期的代码主要分为不同的模块，有AMD和cmd是两种，UMD是两种模块化语法的兼容。

nodejs中自带的模块化是common-js require

ES6当中新的语法主要是 esModules——import



   
## 0070 Webpack热更新的原理是什么


Webpack-dev-server 开启一个内置的开发服务器

web-socket 实现双向通信

Hmr 实现热更新

当代码变化后，webpack 重新编译打包，然后通知 socket 更新到界面上。HMR 实现热更新（局部更新）



   
## 0107 Mvc和mvvm是什么


mvc 和 mvvm 是两种软件架构模式

mvc： model-view-controller 数据层，视图层，控制层。当用户交互时间发生，view 监听事件，将事件传递到 model，model 处理后更新 view 层。同时 View 也可以直接更改 Model 层，类似下面的架构。

<img src="https://cloud.seatable.cn/workspace/32/asset/e82c7317-556e-45c4-8b5d-092331cd8977/images/auto-upload/image-1679384783679.png" width="566" height="null" />

MVVM 就是 model view view-model 三个，架构比上面好一点。这个数据层和 view-model 层进行通信数据交流，ViewModel 和 View 实现自动数据绑定，这个减少了组件代码的耦合。

![](https://cloud.seatable.cn/workspace/32/asset/e82c7317-556e-45c4-8b5d-092331cd8977/images/auto-upload/image-1679384840317.png)

这个最早在安卓端使用较多，还需要看实际的代码，可能一个很好的设计模式，对后续的扩展比较友好。如果一个模块设计的不合适，后续扩展，耦合性很大，就会有很多问题。

总体的设计模式（组件设计）低耦合高内聚，不同功能组件避免耦合。数据层和展现层的分离（例如使用 redux 的设计方案，view 层触发 action，更改对应的 store，重新计算后更新界面，这样就做到数据和视图的分离）。具体问题具体分析。



   
## 0109 Webpack有常用的哪些 plugin 和 loader


loader 主要用于处理不同格式的文件转换

* css-loader (style-loader, css-loader, less-loader, scss-loader) 处理不同的样式，并编译成 css 然后进行打包；file-loader(把小文件打包成JS中)；loader 执行的顺序是从右向左，例如匹配到 .less 文件就是这样执行的 postcss-loader
* resolve-url-loader 解析url()的相对路径
* thread-loader 多线程执行，这个用于多核CPU加速打包活过程
* url-loader： 和file-loader一样，但返回base64 data当文件大小小于某个值时
* babel-loader 把 ES6 代码编译成 ES5 代码等

plugin 处理特殊的功能和需求

* uglyfyJS 丑化代码，压缩代码
* html-webpack-plugin 生成页面
* happypack 也是加快编译效率
* transform-runtime 按需加载 antd-mobile 也是看版本，5以上配置就变化了
* mini-css-extract-plugin

注意：不同版本下 webpack 的配置不一样（从最早的3到5）

详情参考：<https://www.npmjs.com/package/webpack> 



   
## 0125 git 命名规范


\- commit 命名：每次commit，要标准和准确的描述做了什么，改了什么，删除了什么，新增了什么

\- 分支命名：version/1.2.3（大版本分支），feature/login（新增特性分支简写feat）person/michael-an/bugfix-editor（个人分支）special/firefox-debug（特殊分支）前面是大类-后面是功能说明 hotfix（紧急修复分支）

\- tag只能适用稳定的版本



   
## 0126 git 提交 PR 流程


s1:配置 用户名/邮箱/软件界面：

```
git config --global  user.name 'xxx'  
git config --global user.email "xxx@qq.com"

```

右键-options-looks 设置git外观和显示

s2:记录开发过程

初始化仓库——工作区——暂存区——持久区

S3 远程服务器交互

远程代码库（码云，github）

设置：注册

重要：SSH公钥-不同电脑设置不同的key

生成公钥：在bash中生成ssh公钥（具体命令网站上有）生成一个方框图案。将bash中产生的代码复制到码云中。

github 秘钥和公钥产生在我的文档下面.ssh文件夹中。

S4 忽略文件

.gitignore 文件不生效原因：git 中已经包含的文件存在缓存，需要删除这部分本地缓存文件。bash 清空缓存后，可以正常忽略文件。

```
git rm -r --cached .
git add .
git commit -m 'update .gitignore'

```



   
## 0127 软件开发的几种方法


软件工程中开发的几种方式

| 名称         | 定义                                               | 优点                                                      | 缺点                                                |
| ---------- | ------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------- |
| BDD 行为驱动开发 | 确定功能后，直接编辑完成行为的代码                                | 面向行为，项目整体的框架明确，MVC 层划分明确，适合大型项目，适合没有案例的项目（自上而下）         | 可能代码有问题，没有对应的测试文件，后期需要补充测试，考虑边界情况等                |
| TDD 测试驱动开发 | 确定功能，编写测试用例，完成只能实现测试的代码，完善程序                     | 代码健壮性强，针对性强（例如leetcode刷题，或者lodash工具库函数），适合模块化开发代码（自下而上） | 代码完成后，项目整体框架规范可能不一致，没有从顶层处理数据结构。编写测试耗时长。          |
| 瀑布流开发      | 类似BDD，有明确的开发流程：用户调研-产品需求-设计草图-编写代码-测试-上线-反馈与后续维护 | 适合大团队的明确分工，确定所有功能是否需要再动手，避免过程中由于产品需求变动，造成的代码返工等。        | 自上而下的开发，可能后续到测试阶段才发现不足，需要前期大量的会议论证等，需要前期明确的文档和需求  |
| 敏捷开发       | 直接面对用户，用户提出什么需求，就直接开发（二八定律，先不管代码的细节和极少数用户的情况）    | 小步快跑，产品开发较快；适应于自驱力较强的开发者，程序员可以根据用户需求或者自己的体验直接开发功能       | 对于自驱力不强的程序员，没有明确的需求，就很难规范化开发。如果团队成员较多，开发效率并没有那么高。 |

实际上，一个公司可能使用多种开发方法；不同的开发团队（国外开放的理念，国内严格的等级），不同的项目需求，不同的时间限制等等，会采用不同的开发方法。

某一个项目，或者某个开发阶段，也可能有不同的开发方法。

总之：BDD和TDD可以对比，瀑布流开发和敏捷开发可以对比。人多或者情况复杂，需要规范明确，严格定义需要做什么。人员较少，时间紧张，那就优先开发出可视化的结果。

<https://www.zhihu.com/question/19645396>

<https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/7108658>



   
## 0128 软件设计的冗余和性能分析


数据结构的冗余：设计某个字段时，考虑可能扩容，例如单选改成多选，那么就需要从字符串改成数组字符串。如果早期设计中，就设计数组，就不需要考虑兼容早期的代码了。这个还是看需求：如果需求确定，不经常更改，那么就可以考虑性能为主。如果需求经常变化，那么需要考虑冗余。

服务器和硬件层面的冗余：如果主服务器或者主磁盘在某个情况下跑满或者故障，那么需要另一套服务器（或者另一个程序）目前开发的应用还不需要考虑多个系统处理冗余（因为 dev 挂了就修复，内存满了就重启线上服务器，不需要考虑完全不挂的情况）实际上大厂还是需要考虑的，不能线上环境突然挂了然后重启。



   
## 0183 如何提⾼webpack的打包速度


#### （1）优化 Loader

对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，**转换代码越多，效率就越低**。当然了，这是可以优化的。

首先我们**优化 Loader 的文件搜索范围**

```
module
exports
module
rules

// js 文件才使用 babel
test
/\.js$/
loader
'babel-loader'


// 只在 src 文件夹下查找
include
resolve
'src'

// 不会去查找的路径
exclude
/node_modules/

```

对于 Babel 来说，希望只作用在 JS 代码上的，然后 `node_modules` 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。

当然这样做还不够，还可以将 Babel 编译过的文件**缓存**起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间

```
loader
'babel-loader?cacheDirectory=true'

```

#### （2）HappyPack

受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。

**HappyPack 可以将 Loader 的同步执行转换为并行的**，这样就能充分利用系统资源来加快打包效率了

```
module
loaders
test
/\.js$/
include
resolve
'src'
exclude
/node_modules/


// id 后面的内容对应下面
loader
'happypack/loader?id=happybabel'
plugins new HappyPack
id 'happybabel'
loaders
'babel-loader?cacheDirectory'

// 开启 4 个线程
threads 4

```

#### （3）DllPlugin

**DllPlugin 可以将特定的类库提前打包然后引入**。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：

```
// 单独配置在一个文件中
// webpack.dll.conf.js
const
require
'path'
const
require
'webpack'
module
exports
entry

// 想统一打包的类库
vendor
'react'
output
path
join
'dist'
filename
'[name].dll.js'
library
'[name]-[hash]'
plugins
new
DllPlugin
// name 必须和 output.library 一致
name
'[name]-[hash]'
// 该属性需要与 DllReferencePlugin 中一致
context
path
join
'dist'
'[name]-manifest.json'

```

然后需要执行这个配置文件生成依赖文件，接下来需要使用 `DllReferencePlugin` 将依赖文件引入项目中

```
// webpack.conf.js
module
exports
// ...省略其他配置
plugins
new
DllReferencePlugin
context
// manifest 就是之前打包出来的 json 文件
manifest
require
'./dist/vendor-manifest.json'

```

#### （4）代码压缩

在 Webpack3 中，一般使用 `UglifyJS` 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 `webpack-parallel-uglify-plugin` 来并行运行 `UglifyJS`，从而提高效率。

在 Webpack4 中，不需要以上这些操作了，只需要将 `mode` 设置为 `production` 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 `console.log` 这类代码的功能。

#### （5）其他

可以通过一些小的优化点来加快打包速度

* `resolve.extensions`

  ：用来表明文件后缀列表，默认查找顺序是 

  `['.js', '.json']`

  ，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面

* `resolve.alias`

  ：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径

* `module.noParse`

  ：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助

<https://juejin.cn/post/7197061916904898616#heading-3> 



   
## 0204 webpack 中 dev 和 production 环境区别


在开发模式下，直接通过 import 可以导入 CSS 文件。
在生产环境下，会把相互的依赖关系分别打包，然后后端模板中需要插入对应的打包后的JS和CSS文件。这个本地开发测试不出来。

dev正常，build 后不正常的情况，可能是不同开发环境打包逻辑不一样。如果一个模块被引用多次（具体次数根据配置文件决定），那么可能被打包到common.js中，然后影响全局的样式

本地环境下面，只显示项目的CSS，可能在生产环境下，项目中的CSS可能和第三方库的CSS冲突（类名冲突）



   
## 0209 Mvc-mvp-mvvm 的区别


#### MVC 架构

model view controller 

View 是视图层，可以把数据显示在界面，用户直接和视图层交互；Controller 是控制器，主要处理界面的业务逻辑（打开关闭组件等）。Model 是数据层，主要存储底层数据（文件内容，表格信息）。

MVC通信是单向流：View 中用户交互会触发 Controller 控制器，Controller 处理用户输入改变 Model 数据层，数据层改变后会重新渲染 View 视图层。

用户可以与视图层交互，也可以通过URL等直接操作Controller（这是backbone的交互逻辑）

#### MVP 架构

Presenter 展现层，处理大部分的业务逻辑。View 视图层不会部署业务逻辑（根据Presenter被动渲染）。

View 和 Presenter 是双向通信，Presenter 和 Modal 是双向通信。View 和 Modal 不会直接通信。

#### MVVM 架构

将 MVP 架构中的 Presenter 改成 ViewModal。

特点：View 和 ModalView 双向绑定，View 更改后直接体现在 ModalView 中。

原始链接：<http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html>



   
## 0221 polyfill 是什么？作用是？


polyfill 英文翻译：垫片；计算机中指的是"补丁"

为什么使用：老版本浏览器需要较早的语法才能使用（IE11不能使用Object.assign）所以需要通过 babel 把高级语法转换成低级语法。我们可以设置需要支持的浏览器版本（例如使用babel 转换到 es3 还是 ES5 版本）。早期的版本需要更多代码，如果不想兼容 ie 678 那么可以节省不少代码。

垫片（补丁）分类

```
@babel/preset-env
@babel/runtime
@babel/folyfill
@babel/transform-runtime
core-js

```

补丁使用方法：手动、半自动、全自动。

1、手动：根据需求，安装对应的第三方库 `Object.assign = require('object-assign')` 不利于维护。

2、半自动：根据 webpack 覆盖率：preset-env 根据预设的环境打补丁 https\://github.com/browserslist/browserslist 在配置文件中设置 corejs 和 targets 版本，即可打包对应版本的代码。

3、自动：polyfill.io 这个库可以根据浏览器的 UA 自动判断不同版本的代码并处理  https\://polyfill.io/v3/  chrome 会不处理，IE 会转换。

参考链接：<https://zhuanlan.zhihu.com/p/71640183>



   
## 0222 thread-loader 多进程多线程打包


webpack 编译打包时间较多，可以使用 thread-loader，可以减少 webpack 打包编译时间

<https://github.com/webpack-contrib/thread-loader>

先定量分析一下打包时间，在耗时较多的 loader 前，使用 thread-loader 处理，使用单独的进程进行打包

多CPU的情况下，可以节省时间（8核节省75%的时间）

如果只使用 babel 转换，不使用 webpack 打包，那么影响不大

```
{              
    test: /\.(js|mjs)$/,
    exclude: /@babel(?:\/|\\{1,2})runtime/,              
    use: [
      {
        loader: 'thread-loader',
      },
      {
        loader: require.resolve('babel-loader'),
        options: {
          babelrc: false,
          configFile: false,
          compact: false,
          cacheDirectory: true,
          cacheCompression: false,
        },
      }
    ],
}

```



   
## 0260 团队中不同项目，如何避免干扰


团队中的问题以及解决方法

一个子项目中，不同子项目互相干扰，冲突的解决办法

1. 代码规范统一：制定统一的规范（接口规范，UI规范，commit 规范等）
2. UI 的统一：不同的子项目使用不同的前缀（CSS，公共组件）
3. 编程能力统一：不同的同事水平不一样，那么按照中等的水平作为整体的标准（react hook typescript 等技术，根据团队技术水平决定）项目设置成不同的模块，不同人完成不同的模块，只要求接口统一
4. 增加自动监测模块（单元测试，集成测试）整体项目的水平的保证



   
## 0261 如何重构代码和组件


为什么要重构？

原因：一个组件功能低耦合高内聚。历史原因，如果一个组件功能繁杂，逻辑比较乱，代码量很大，不便于管理，那么应该进行重构。

重构步骤：

1、理解功能：把当前组件的代码读懂，并理清不同的功能和界面匹配

2、划分重构边界：根据功能确定划分的部分（功能分类，还是界面分类），然后把不同的核心代码分开

3、迁移核心代码到不同子组件，优先调试小组件，并测试核心代码和传参正确性（import部分直接全部复制）

4、迁移类型检验，删除无用代码

5、重新整理类名，函数名等；微调内部结构。

6、最后判断预期效果是否达成。如果没有达到预期效果，或者重构后仍然有问题，需要重新开始前面步骤。

具体思考

1、项目开始前，就应该约定各种组件的规范，后期更改很麻烦，还可能有未知的错误和问题

2、自己写公共组件一定注意细节，这里需要多看官方组件的源代码，看看别人怎么写的。

为什么要写自己的组件？能不能使用传参优化已有的组件，避免造轮子是最好的，也要有造轮子的能力



   
## 0266 鲁棒性是什么


鲁棒性 Robust 健壮性

代码或者服务在不良环境下的稳定性，如果某个上下游服务延迟，或者高并发，是否有配套方案解决这个问题？例如支付宝接口的响应时间延迟，表现在线上就是淘宝支付的商品未付款。如果判断网络情况不好，需要自动降级或者友好提示。

或者用户输入的不符合规范，或者网络情况较差等，代码能否满足基本功能



  