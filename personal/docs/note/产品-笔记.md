# 产品笔记 

 原始表格链接：https://cloud.seatable.cn/dtable/external-links/59b453a8639945478de2/

 
## 0187 表单长度设计原则


如果是一个 toC 的产品，设计一个调查问卷或者表单，表单项最好不要太长。如果一个表单需要用户填写消耗5分钟以上，大部分用户都会没有耐心。如果是必填的项，那么用户可能随便填写，这样调查就失去了正确性。



所以需要根据用户的水平，确定表单的长度和深度，尽量让用户做选择题，而不是让用户做填空题，而且这样更便于用户填写，便于最后数据分析整理等。



如果表单确实很长，那么可以尝试分页显示，然后顶部显示进度条，表示用户填写了多少表单项。



界面加载过程类似：尽量减少加载时间，时间小于3S，界面显示 loading 图标。加载时间超过 5秒，最好显示进度条。如果已经确定加载的框架，只是需要后台返回数据，那么可以先显示骨架屏。



具体参考：

<https://developers.weixin.qq.com/miniprogram/dev/devtools/skeleton.html>

![](https://res.wx.qq.com/wxdoc/dist/assets/img/progressiveLoad.722964c8.gif)



   
## 0342 简单设计一个后台管理系统


如何做后台管理系统？

可以参考实际项目和小说项目进行说明

#### 功能层面

* 用户管理：用户的增删改查
* 群组管理：某个群组对应的用户和权限（ToB 和 C的区分）
* 权限管理：权限增删改查
* 通知管理：新增全局通知，删除全局通知
* 产品管理（表格，小说）：具体说某个产品的内容管理，数据变化趋势（图表的库等），表格和折线图等都可使用
* 投诉管理：处理用户投诉的表格和信息

后台管理系统的交互细节可以不需要很细，主要是展示数据的整理变化

#### API 层面

后台管理相关 API 通常单独写，加一个 system-admin 前缀，用于和普通 API 的区分

每次进入后台界面，需要单独验证管理员信息，这里设置的 token 过期时间比较短，可能几个小时。相对于应用网页 token 过期时间可能比较久（7天或者30天等）





   
## 0348 文件断点续传






主要逻辑：文件切片——上传切片——合并切片——验证切片。

前端浏览器读取文件后，把文件切片后，每一个片段分片上传（滑动窗口算法），然后后端接收到切片后，返回当前已经上传的文件大小，然后把切片放在硬盘的临时目录下。后端检测全部上传后，拼接成完整的大文件，然后把文件路径和成功信息返回给前端。

特殊处理：如果某个切片没有上传到（丢包），那么前端需要循环上传没有成功上传的切片。如果中途网络中断，那么就暂停上传进程。等网络恢复后，再次上传，就实现了断点续传。

适应于大于10M小于1G的文件。超过1G的文件，可能浏览器无法读取到内存中。

后端 Java 实现：<https://juejin.cn/post/7266265543412351030> 

后端 express 实现：<https://juejin.cn/post/7233613362888966205> 



   
## 0357 输入框插入图片


Table 中的做法是：

创建一个 div 富文本编辑器，然后插入对应的图片节点，协作人节点。

然后删除时，可以删除对应的节点。这样也支持复制粘贴图片上传，后续可以写个技术文档。content=editable

主要步骤：编辑HTML、提交(转义)、发送到服务器、请求返回本地、渲染只读的HTML

编辑内容如下

```
test <img src=\"https://2024-02/bird.jpeg\" height=\"60\"> @foo

```

渲染评论

```
dangerouslySetInnerHTML={{ __html: commentContent }}

"rest @foo <img src=\"https://test.png\" height=\"60\"> ",

```



   
## 0421 文档树


需求：一个文档树，前端如何维护和更新？

阶段1：静态文档树渲染

* 从后端获取到文档结构（字符串），使用 JSON.stringify 方法转换成对象，进一步转换成有效的树结构（如果后端存储的是树结构，可以直接使用；如果候选存储的是数组，需要把数组每一项遍历，前端建立树结构）

* 把 JS 树渲染成 JSX 树结构（对应有 Folder 对象，File 对象，界面上不同层级渲染不同的树节点）

* 文件夹支持展开和折叠

阶段2：支持文档树编辑

* 增加：在某个文件夹节点，下面新增一个文件夹或者文件节点

* 删除：删除某个文件夹或文件夹点（同时删除内部的子树）

* 重命名：更改某个文件或者文件夹属性

* 复制：把一个子树节点，复制到另一个节点（注意需要深拷贝树节点）

* 保存：把树结构转换成字符串，发送到服务器

阶段3：支持复杂操作和边界情况

* 通过菜单移动：把一个子树节点，移动到另一个子树节点

* 通过拖拽移动

  * 采用 react-dnd 库，设置全部的节点可以拖动，拖动时包括内部节点；

  * 设置全部的文件夹可以被释放，根据释放的位置，三种情况：

    * 文件夹上面10px 就是移动到文件夹的前一个节点（渲染释放线）

    * 文件夹下面10px 就是移动的文件夹的后一个节点（渲染释放线）

    * 文件夹中间，移动到文件夹内部（背景变色）

  * 设置全部的文件可以被释放，两种情况，分别是前一个位置和后一个位置（渲染释放线）

* 支持撤销（每一个操作记录到数组中，当撤销时，使用 revert 函数获取对应的反向操作）

* 支持本地文件拖动到浏览器树结构（把本地文件上传到服务器，服务器返回路径，然后插入到树中）

* 判断最大树嵌套深度（避免树深度过深，或者某个文件夹内部太多文件，造成性能问题）

   
## 0422 图片懒加载


为什么要做图片懒加载？如果一个网页有很多图片，初始网页就加载全部的图片，下载图片比较慢，给服务器带来很多压力。解决的办法就是界面滚动到某个位置后，然后再加载这个位置的图片。适应于内容很多的长网页的实现，例如画廊等。

技术实现：

1、默认把 img 标签的 src 设置一个空，或者是 loading 动画，这样可以从缓存中获取动画。

```html
<div className="container">
    <img src="./loading.gif" alt="" data-src="http://www.baidu.com/logo.png" />
    <img src="./loading.gif" alt="" data-src="http://www.baidu.com/logo.png" />
    <img src="./loading.gif" alt="" data-src="http://www.sina.com/logo.png" />
    <img src="./loading.gif" alt="" data-src="http://www.taobao.com/logo.png" />
</div>
```

2、计算当前图片是否在网页视口中，也就是计算图片距离网页顶部的位置，和当前滚动位置和屏幕高度。

```javascript
componentDidMount() {
    this.checkLoad();
}

onScroll = () => {
    this.checkLoad();
}
```

3、监听界面垂直滚动事件（节流监听），当某个图片开始进入网页内部（或者即将进入网页内部），那么设置成真实的 src，向服务器发出请求，界面显示图片，就实现了图片的懒加载。伪代码如下：

```javascript
function checkLoad() {
    // 检测当前图片是否在视口内部
    // 图片距离顶部的距离 < 网页滚动距离 + 屏幕高度
    const isLoad = imageOffsetTop < containerSrollTop + window.innerHeight
    if (isLoad) {
        img.src = img.getArrtibute('data-src');
    }
}
```

​

   
## 0432 鼠标经过切换图片


需求：鼠标经过，切换到另一张图片（犀牛书 21 章第一节的案例，JavaScript权威指南）

原理：把一个图片地址和另一个图片的地址设置到节点中，然后鼠标经过，获取 data 属性然后改变 src 属性，这样实现了图片切换。为了避免缓存，可以先 JS 创建图片，然后直接从缓存中读取图片。

HTML

```html
<img src="https://michael18811380328.github.io/background/pub_31.jpg" data-rollover="https://michael18811380328.github.io/background/pub_32.jpg"/>
```

JS

```javascript
  window.onload = (function() {
    for (let i = 0; i < document.images.length; i++) {
      let img = document.images[i];
      let rollover = img.getAttribute('data-rollover');
      // 忽略没有 rollover 属性的图片
      if (!rollover) continue;
      // 缓存图片
      (new Image()).src = rollover;
      img.setAttribute('data-rollout', img.src);
      img.onmouseenter = function() {
        this.src = this.getAttribute('data-rollover');
      }
      img.onmouseleave = function() {
        this.src = this.getAttribute('data-rollout');
      }
    }
  });
```

本地浏览器调试时，应该设置浏览器允许缓存，这样首次加载全部图片后，然后鼠标进入滑出就不会再次从服务器获取图片了。

上面是原生 JS 的实现，如果是 react 在不同的 image 上绑定 mousenter - mouseleave 事件即可

   
## 0434 mp4 视频转换成 m3u8 格式展示


参考：[https://blog.csdn.net/weixin\_41697143/article/details/139750963](https://blog.csdn.net/weixin_41697143/article/details/139750963 "https://blog.csdn.net/weixin_41697143/article/details/139750963")

   
## 0442 文件上传的几种情况


#### 普通文件上传

```javascript
function fn(files) {
  if (files.length) {
    // 优化：如果上传多文件，可以使用循环上传（上传多文件 input multiple 有一部分浏览器不支持，移动端和打开的APP有关）
    for (let file of files) {
      let reader = new FileReader();
      // 不同类型的文件，使用不同的编码上传（readAsText, readAsDataURL）
      // 通常根据文件名后缀判断文件类型，更严格的方法是根据文件开头的编码判断（文件后缀和真实文件类型可能不一样）
      if (/.txt/.test(file.type)) {
        // txt file
        reader.onload = function() {
          console.log(this.result);
        }
        reader.readAsText(file);
      }
      else if (/.png/.test(file.type)) {
        // image file
        reader.onload = function() {
          console.log('success');
        }
        reader.readAsDataURL(file);
      }
    }    
  }
}
```

#### 大文件分片上传

大文件分片上传思路（详见开课吧笔记）

* 先把 file 异步读取到 JS 内存中 (fs.readFile)

* 类数组切片成 chunks (files.slice(current, current + chunkLength))

* 前端生成一个 hash (三种方法，idle，布隆过滤器)&#x20;

* 然后 chunks.map() 给每一个分片name加上hash，调用 API 并上传，根据上传的chunks数量，设置进度条。

* 上传后，需要后端协同处理（根据文件的 hash 确定文件唯一性，然后根据 chunk 的 index 进行排序，把多个文件片段合并后，存储到数据库）

* 特殊：如果丢失分片，类似网络请求丢包处理思路（断点续传或者重传）前端再次传递分片

#### 其他特殊情况：

* 很多小文件上传（本地JS压缩成一个文件，本地用 JSZip 或者 gzip 等格式，然后后端收到再解包）；

* 网络很差（经常中断）前端后端需要查询是否某个片段已经上传，来确定是否重新上传等（断点续传）

* 拖拽文件上传，复制粘贴上传（需要调用前端的事件获取文件，监听 DIV 的 drag drop 事件，然后从 event 中获取文件）

​

  