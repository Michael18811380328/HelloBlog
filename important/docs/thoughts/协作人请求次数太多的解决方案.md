# 协作人请求次数太多的解决方案

## 问题

表格中有协作人列，每一个列存储 email，需要发出请求，返回具体的用户信息。如果行非常多，请求次数很多，容易造成服务器端 503 错误。

示例代码如下

~~~js
API.getUserInfo(email).then(res => {
  this.setState({ creator: res.data })
});
~~~

## 个人解决思路

个人的思路：把界面上全部的行遍历一次，获取 email 数组，发出一个请求，获取到用户信息列表，然后渲染界面。问题：可能遍历一次行很耗时，或者其他地方也会使用这个请求，例如修改记录，创建者，分享，所以一次性遍历全部行，这个成本较高，后期也不好维护。

## 团队解决思路

当某处需要获取用户信息时，先把请求以及回调函数，发给某个统一的对象，分别放在 emails 和 callbacks 数组中。每个一秒批量发出请求获取 users 信息，然后循环 callback 函数，回调函数中找到对应的 user，完成功能。

伪代码

~~~js
// 业务代码
let callback = (userMap) => {
  // 回调函数中找到对应的 user
  let user = userMap(email);
  this.setState({ creator: user });
}

findUser(email, callback);
~~~

~~~js
// 用户处理代码
// 新建两个临时队列，存放邮件和回调函数
let emails = [];
let callbacks = [];
let emailUserMap = {};

findUser = (email, callback) => {
  callbacks.push(callback);
  emails.push(email);
}

setInterval(() => {
  if (emails.length > 0) {
    // 去重
    emails = Array.from(new Set(...emails));
    // 查询邮箱
    API.getUsersInfo(emails).then(res => {
      let users = res.data.users;
      // 将结果存储到对象中，避免查找过程中时间复杂度比较高
      user.forEach(user => {
        emailUserMap[user.email] = user;
      });
      // 执行全部的回调函数
      callbacks.forEach(callback => {
        callback(emailUserMap);
      });
      // 清空队列
      this.emails = [];
      this.callbacks = [];
    });
  }
});
~~~

这个方法可能的问题：如果网络条件不好，所有的用户都无法获取。可以改成循环函数查询。

完整代码：

~~~js
const PENDING_INTERVAL = 1000;

class UserManage {
  constructor() {
    this.waitingEmails = [];
    this.waitingCallbacks = [];
    this.emailUserMap = {};
  }
  	
  // 组件查询用户（某个组件可能查询多个 emails）
  queryUsers(emails, callback) {
    if (!Array.isArry(emails) || emails.length === 0) {
      return;
    }
    let valids = [];
    emails.forEach(email => {
      this.waitingCallbacks.push(callback);
      if (this.emailUserMap[email] || this.waitingEmails.includes(email)) {
        return;
      } 
      valids.push(email);
    });
    if (valids.length === 0) {
      return;
    }
    this.waitingEmails.push(...valids);
    this.startQueryUsers();
  }
  
  // 批量查询用户
  startQueryUsers() {
    if (this.pendingTimer || this.waitingEmails.length === 0) {
      return;
    }
    this.pendingTimer = setTimeout(() => {
      API.listUserInfo(this.pendingEmails).then(res => {
        const { user_list } = res.data;
        // this.emailUserMap = user_list.forEach
        this.queryUserCallback();
      });
      clearTimeout(this.pendingTimer);
      this.pendingTimer = null;
    }, PENDING_INTERVAL);
  }
  
  queryUserCallback() {
    this.waitingCallbacks.forEach(callback => {
      callback(this.emailUserMap);
    });
    this.waitingEmails = [];
    this.waitingCallbacks = [];
  }
}
~~~

