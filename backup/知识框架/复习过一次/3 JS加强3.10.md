### 6 JS加强

#### 第1天 判断-循环

{JS简介、script标签属性、变量、数据类型及转换、操作符、判断语句、循环}



##### 0.1 JS 介绍



###### 0.1.1 JS作用

早期：浏览器与服务器之前的请求与交互，判断浏览器的输入情况，减少服务器的压力。

当前：

页面特效（PC端网页效果）

移动端（移动web和APP界面）

异步与服务器交互（Ajax）

服务端开发（node.js）。

当前主要学习页面特效（结合CSS）

案例网站：www.webhek.com

www.codecombat.cn （在ie11版本运行）



###### 0.1.2 浏览器运行原理

https://www.2cto.com/kf/201202/118111.html

```html
user interface 用户界面（浏览器显示）

rendering engine 渲染引擎（用来显示请求的内容，执行代码，渲染CSS属性，渲染HTML代码）

JavaScript interpreter JS解析器（执行JS代码）

browser engine 浏览器引擎，用来查询和操作渲染引擎（rendering engine）

networking（发送接收网络请求）

UI backend （UI后端）用来绘制类似组合框和弹出窗口（alert）

Data persistence （数据持久化）数据存储，cookie HTML5 中的session Storage（会话存储层）。

```

###### 0.1.3 脚本语言

JS是脚本语言script（Python和JS）（脚本语言需要解释：一行一行解析，解析一行后执行一行（需要解释器）JavaScript interpreter。JavaScript是一种客户端脚本语言（浏览器））

C和java是程序语言（需要编译：一次性将代码转化为二进制（汇编语言），执行速度更快。）



B/S browser/server 浏览器/服务器 网页程序

C/S client/server 需要客户端的程序（QQ）

这是两个不同的架构



##### 1.1  JS 组成

ECMA Script（JS语法规范）-当前学习内容

DOM document object model 文档（网页）对象模型-操作网页的接口

BOM browser object model 浏览器对象模型-操作浏览器接口



##### 1.2 JS 标签属性

1.2.1 src=“javascript/main.js” 表示外部JS的路径。如果引用外部JS，那么这个script标签中的JS代码就不会执行。type="text/javascript"  表示脚本语言为JS（默认的脚本语言，H5以后版本可以不写，现在要求都写上）async="async" 立即异步下载JS文件（20ms）下载结束后立即执行JS代码

同步（一个人有序的做多件事情，一个浏览器执行代码从上到下执行 sync）。异步：async="async"：异步（node js 多个人同时做多件事）。async：只有一个值。只要main.js下载完毕即可执行（主程序HTML代码不会中断执行）。

 defer="defer"异步下载JS代码，下载结束后不执行。等HTML中代码加载执行完之后，再执行JS代码。

JS中不能直接操作内存地址（C语言可以直接操作内存地址）



##### 1.3 变量

不使用第三个变量，交换两个number类型的数值方法，代码多练习。

弱类型：声明变量时不确定变量的类型；变量类型确定后可以更改（不推荐）。

变量的名称有实际意义；变量首个单词小写，后一个单词首字母大写。

注释建议使用单行注释（多行注释存在嵌套问题有bug）对于function可以使用多行注释，说明函数和参数的意义。js文件的首位可以使用多行注释说明作者和时间。



##### 1.4 数据类型



###### 1.4.1 number

浮点数bug：部分浮点数计算存在bug。不建议比较两个浮点数的大小（0.1+0.2！=0.3）,不要测试两个浮点数的具体数值。

参考网站：https://www.cnblogs.com/xinggood/p/6639022.html

原因：电脑中浮点数使用二进制数进行存储，部分浮点数转化成无限不循环小数，在计算过程中出现误差。在C、C++、java中对方法进行封装，避免这个问题出现。在JS中弱类型语言没有进行封装，所以出现这种情况。

常用方法1：先同时乘以一个整数10，之后parseInt转换成整数比较大小。

常用方法2：调用.toFixed(1)进行计算，计算结果不精确（不同浏览器结果可能不同）

数据的最大值和最小值都可以有（通常计算足够使用）infinity和-infinity表示正无穷大和负无穷大

Number.MAX_VALUE表示最大值

判断用户输入数据是否为数字：isNaN(参数) true—不是数字——用户输入是否合法



###### 1.4.2 string

获取字符串的长度的方法是length（数组的长度也是length方法）转义符（特殊符号的输出）记住\t \n

**重要**：**字符串不可变性**：一个字符串占用一定内存，改变字符串时不会立即删掉之前旧的字符串，会新使用内存进行存储。JS短期内（程序执行过程中）不会清除内存。如果循环结构中多次更改字符串，将会消耗大量内存，可以使用数组解决这个问题。

字符串不可变性的优点：如果不同参数有相同的字符串值，可以共用一个内存地址；之前不同的字符串会占用内存地址，如果后期另一个字符串内容一致，可以使用前期字符串的内存地址。（地址重复使用）



###### 1.4.3 Boolean

结果是false的五种情况：**空、0、null、undefined、NaN** （这五个都是特殊的空值）

判断一个变量是否有具体值？使用IF（a）{执行语句}



###### 1.4.4 undefined

undefined的字面量是undefined

字面量：某一个数据类型的字面表达（“234”）

——学过的东西都记住（以后使用的时候没有时间查找笔记了）



##### 1.5 数据类型转换

1.String函数和toString方法的使用：

String适应于所有数据转换；**toString对于undefined和Null不能使用**，所以除了这两个特殊类型，其余常用toString方法进行转换。使用+“”空字符串也经常用。



2.number转换补充：

number函数 parseInt方法和parseFloat方法。

parseInt可以添加两个参数（需要转化的数据和进制数），其他两个都是一个参数。

parseInt遇到字符串，转换前几位数字，后边的字母符号不转换。



##### 1.6 操作符

&&是串联电路 ||是并联电路 ！是门电路

当逻辑运算符左右都是逻辑值，符合上面的情况；

当左右是字符串，属于特殊情况。||更常用。

&&

如果两个条件都是true（大部分情况），输出的结果为&&后边的值；

如果两个条件有一个是false，输出的结果是假的那个条件（后面的条件）；

如果两个都是false，程序不能执行到第二个条件（电流到不了第二个电阻）返回第一个条件。

||

如果第一个是true，不访问第二个对象，直接返回第一个对象；

如果第一个是false，第二个是true，访问第一个对象不能通过，返回第二个对象；

如果两个都是false，程序走到第二个走不动了，返回第二个对象。

常用情况：在计算中，如果给定的书没有值，使用默认值进行计算

```html
function sum(num1 num2) {
//求和函数，默认两个数都是数字，检验用户输入数据的合法性
n1= num1 || 0;
n2= num2 || 0;
//如果输入数据是undefined 改变为默认的0，否则函数计算结果是NaN
sum= n1+n2;
return sum;
}
```



##### 1.7 判断循环

if 中===比==运行速度更快，判断的准确性更高。所以，如果确定是相同的数据类型，尽量使用===。

在switch中，条件和选择是全等的关系，如果数据结构不对，只能输出default；每一个case后需要使用break（否则每一个结果都会输出；（特例：多个选项一个结果）

if使用范围更广（是一个区间），switch适合于特定有限的数。如果是成绩转化为等级，可以首先将成绩（100分制）除以10转化为小数，使用parseInt转化为整数，之后使用switch进行分类判断。

对于简单的if—else结构，使用三目运算符（？）更方便。通常情况，代码较多更好理解，代码越少执行越快。

for循环和while循环

当循环次数已知的时候是for循环；当循环结束的条件已知时候使用while循环；



##### 1.8 练习

###### 1.8.1 兔子数列

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//程序一：输出1-100及和
		var sum = 0;
		for(var i=1 ; i<=100; i++){
			console.log(i);
			sum = sum + i;
		}
		alert("程序结束，1-100和为"+sum);
      
		//程序二：计算兔子数列第12个数：分别使用数组和简单方法
      
		//数组array方法，注意数组从0开始，
		var a = new Array;
		a[0]=1,a[1]=1;
		console.log(a[0]);
		console.log(a[1]);
		for (var j=2 ; j < 12 ; j++) {
			a[j]=a[j-1]+a[j-2]
			console.log(a[j]);
		}
		alert("兔子程序数组for方法over");
      
		//常规方法
		var num1=1, num2=1, num3=0, tem=3;
		console.log(num1);
		console.log(num2);
		while(tem<=12){
			num3 = num2 + num1;
			num1 = num2;
			num2 = num3;
			tem +=1;
			console.log(num3);
		}
		alert("兔子程序while方法over");
	</script>
</head>
<body>
</body>
</html>
```

###### 1.8.2 九九乘法表

控制台输出（大+小）

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//乘法表本质是for双重嵌套
		var mul=1;
		for (var i=1 ; i<=9; i++){
			for (var j=1; j<=9; j++){
				mul= i*j;
				console.log(i+"*"+j+"="+mul);
			}
		}
		alert("over");
	</script>
</head>
<body>	
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//乘法表本质是for双重嵌套
		var mul=1;
		for (var i=1 ; i<=9; i++){
			for (var j=1; j<=i; j++){
				mul= i*j;
				console.log(i+"*"+j+"="+mul);
			}
		}
		alert("over");
	</script>
</head>
<body>
</body>
</html>
```

###### 1.8.3 九九乘法表

窗口输出

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		}
		table {
			margin:50px auto;
			width: 600px;
			height: 400px;
			background-color: pink;
			border:1px solid black;
		}
		td {
			border:1px solid red;
		}
	</style>
	<script>
		document.write("<table>");
		for (var i=1 ; i<=9 ; i++){
			//外层循环
			document.write("<tr>");
			for (var j=1; j<=i ; j++){
				//内层循环
				document.write("<td>");
				document.write(i+"*"+j+"="+(i*j));
				document.write("</td>");
			}
			document.write("<tr>");
		}
		document.write("</table>");
	</script>
</head>
<body>
</body>
</html>
```

###### 1.8.4 正方形输出

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>正方形的输出</title>
	<script>
		for (i=0; i<10; i++){
			//外层循环
			for(j=0; j<15; j++){
				//内层循环
				document.write("☆");
			}
			//使用插入HTML标签换行
			document.write("<br />");
		}
	</script>
</head>
<body>
</body>
</html>
```





#### 第2天 循环-数组

##### 2.1 循环

###### 2.1.1 终止循环

区别：continue结束本次循环（循环内部continue后边的代码本次不执行），开始下次循环（在for循环中使用）；break表示直接跳出循环（在switch中使用）。

while 和 for语句结束之后都是大括号，不适用分号。do-while之后结尾需要加分号。

**prompt(“提示内容”，“默认参数”)** 默认参数是文本框预设的参数（用户可能输入各种非法参数，首先进行检验用户参数的合理性）；

程序：判断用户输入是否为数字？

首先将用户输入的字符串转化为数字（整数）。使用parseInt-number 函数之后，使用逻辑值判断。如果用户输入字符串直接转化为NaN为false（特殊：用户输入0需要特殊处理）。

可以设置一个while循环为true死循环，内部嵌套一个if函数，如果符合某个条件直接break也可以实现；

###### 2.1.2 练习

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//计算1-1000内不能被7整除的数的和，如果和大于500终值并输出和
		for (var i = 1 , sum = 0 ; i <=1000; i++) {
			if(i % 7 == 0) {
				continue;
				//如果是7的倍数，直接跳出本次循环
			}
			sum += i;
			if (sum > 500) {
				console.log(sum+"\n"+i);
				break;
				//如果和大于500，直接终值循环
			}
		}
		alert("over");
	</script>
</head>
<body>
</body>
</html>
```



##### 2.2 数组

###### 2.2.1 特点

数组是一个有序的排列（从0到Array.length-1)。数组内部可以包含任何类型的数据；一个数组内部存储的数据类型尽量一致。

###### 2.2.2 遍历

（正反遍历）：可以使用for进行遍历，也可以直接输出整个数组（其他程序语言不能实现）。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		var array = new Array ;
		//数组的赋值
		for (var i = 0 ; i < 10 ; i++ ) {
			array[i] = i + 1 ;
			console.log(array[i]);
		}
		//数组的遍历
		for (var j = 0; j < array.length ; j++) {
			document.write(array[j]);
			document.write("<br />");
		}
		//输出数组全部
		console.log(array);
      	console.log(typeof(array));
		alert("over");
	</script>
</head>
<body>
</body>
</html>
```

###### 2.2.3 赋值

var array = [ ] ; 定义一个长度为0的空数组；

如果没有给数组某一个位置赋值，其结果是undefined，数组最好连续赋值。不连续赋值浪费空间。

###### 2.2.4 长度

在循环结构中，array[array.length] 直接表示下一个未赋值的空位置，不用使用新变量，也不用使用array[ (num-1)/2 ]的方法表示。每当新增加一项数值，数组的长度就会增加一个，这是默认的一个序列。

```html
		var array2 = [];
		for (var k = 1; k<10; k++) {
			if(k % 2 != 0) {
				array2[array2.length] = k;
			}
		}
		console.log(array2);
		alert("over");
```

特殊：

array.length 可以直接赋值（之前多余的数据可能被覆盖）其他语言没有这个功能。改动长度后，前边的元素还保留。

创建数组：var array = [ 3 ]; 数组中有一个元素3；——目前通常使用这种方式

创建数组对象： var array = new Array ( 3 ) ; 数组对象的长度是3（三个元素未赋值）；

创建数组对象： var array = new Array ( "3" ) ;数组只有一项，3； 

设置数组中的每一项： var array = new Array ( 1,2,3,4,5 )； 



##### 2.3  练习

###### 2.3.1 求最值

习题：求一个未知数组的最大值，最小值（只用一个循环），并求最值的索引。

求最值：不断进行比较，设置max和min；使用for循环依次对比最值和数组中的数是否相等，输出位置即可。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//求一个未知数组的最值及位置（索引）
		var array = new Array(1,2,4,5,2,1,6,8,2,6,3,6,4,9);
      
		//查看数组长度及内容
		console.log(array.length);
		console.log(array);
      
		//求最值
		var max = array[0], min = array[0];
		for (var i = 1; i < array.length ; i++) {
			if (array[i] > max) {
				max = array[i];
			} 
			else if (array[i] < min) {
				min = array[i];
			}
		}
		console.log(max);
		console.log(min);
      
		//计算最值位置(如果最值有若干个位置这样处理)
      	//或者初始化sum为0，if后面加入sum++，出现一次最大值向后加一个数，算法更简单
		var num1 = 0, num2 = 0;
		for (var j = 0 ;j < array.length ; j++) {
			if (array[j] == max) {
				console.log("The max number is in "+(j+1));
				num1 ++ ;
			}
			if (array[j] == min) {
				console.log("The min number is in "+(j+1));
				num2 ++ ;
			}
		}
		console.log("最大值"+num1+"个");
		console.log("最小值"+num2+"个");
		alert("over");
	</script>
</head>
<body>
</body>
</html>
```

###### 2.3.2 字符串输出

习题：将一个字符串数组的每一个元素输出，中间使用符号间隔。（最后一个没有符号间隔）

考点：数据类型的转换。新建一个字符串变量，使用for循环每次都在这个字符串变量后加入字符串和符号。

方法一：首先将数组第一个字符串提取出来，之后每一个加入一个|在加入下一个字符串。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
	//将一个字符数组中的每一个字符串输出，之间加入符号
	//方法一：将第一个字符串输出，之后依次输出符号和其他字符串，循环实现，可能比较占用内存
	var array = ["jide","hude","mami","daxi"];
	console.log(array);
	var tem = array[0];
	for (var i = 1; i < array.length ; i++) {
		tem = tem + "|" + array[i];
	}
	console.log(tem);
	alert("method one over");
	</script>
</head>
<body>
</body>
</html>
```

###### 2.3.3 去除0

习题：将数组中的0去掉，并放置在新的数组中。

方法：原始数组和新建数组。遍历数组，进行IF逻辑值判断，如果是0对应false不进行赋值。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
	//练习：将一个字符数组中的非零元素输出到新数组中
	//思路：非零元素if逻辑值判断
	var array = [4,6,7,2,5,7,0,5,1,4,0,8,0,2];
	var newarray = [];
	for (i = 0 ; i < array.length ; i++) {
		if (array[i]) {
			newarray[newarray.length] = array[i];
		}
	}
	console.log(newarray);
	</script>
</head>
<body>
</body>
</html>
```

###### 2.3.4 倒转数组

习题：数字数组倒转数组。

方法一：求出原始数字数组的长度，循环长度的一半进行调换数值，通过一个中间变量调转数组。（更简单）

方法二：新建一个数组，直接将最后一项放到新数组的第一项中。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript">
		//数组倒转
		//方法一：新建数组
		var array = [1,2,3,4,5];
		var newarray = [];
		for (var i = 0 ; i < array.length ; i++) {
			newarray[i] = array[array.length-i-1]
		}
		console.log(newarray);
		//方法二：直接原始数组倒转
		var array = [1,2,3,4,5];
		var tem;
		for (i = 0 ;i <= Number(array.length/2) ; i++) {
			tem = array[i];
			array[i] = array[array.length-i-1];
			array[array.length-i-1] = tem;
		}
		console.log(array);
	</script>
</head>
<body>
</body>
</html>
```

###### 2.3.5 冒泡排序法

习题：数组冒泡排序法。

比较前后两个元素大小，使用for嵌套依次将最大值提前。

分别计算内循环和外循环的次数（做对的前提下）。

方法一：

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript">
		//冒泡排序法 计算内循环和外循环次数
		//方法一
		var array = [1,2,4,5,2,1,6,8,2,6,3,6,4,9];
		//默认第一项是最小值,number1和2分别是内外循环的次数
		var tem ;
		var number1 = 0 , number2 = 0 ;
		for (i = 0 ; i < array.length ; i++) {
			for (j = 1 ; j < array.length ; j++) {
				if (array[j] < array[j-1] ) {
					tem = array[j-1];
					array[j-1] = array[j];
					array[j] = tem;
				}
				number1 ++;
			}
			number2 ++;
		}
		console.log(array);
		console.log("数组的长度为"+array.length);
		console.log("内循环的次数为"+number1);
		console.log("外循环的次数为"+number2);
	</script>
</head>
<body>
</body>
</html>

数组的长度为14
内循环的次数为182
外循环的次数为14
```

方法二：

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript">
		//冒泡排序法 计算内循环和外循环次数
		//方法二
		var array = [1,2,4,5,2,1,6,8,2,6,3,6,4,9];
		//默认第一项是最小值,number1和2分别是内外循环的次数
		var tem ;
		var number1 = 0 , number2 = 0 ;
		for (i = 0 ; i < array.length ; i++) {
			for (j = 1 ; j < array.length - i ; j++) {
				if (array[j] < array[j-1] ) {
					tem = array[j-1];
					array[j-1] = array[j];
					array[j] = tem;
				}
				number1 ++;
			}
			number2 ++;
		}
		console.log(array);
		console.log("数组的长度为"+array.length);
		console.log("内循环的次数为"+number1);
		console.log("外循环的次数为"+number2);
	</script>
</head>
<body>
</body>
</html>

数组的长度为14
内循环的次数为91
外循环的次数为14
```

方法三：

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript">
		//冒泡排序法 计算内循环和外循环次数
		//方法三
		var array = [1,2,4,5,2,1,6,8,2,6,3,6,4,9];
		//默认第一项是最小值,number1和2分别是内外循环的次数
		var tem ;
		var number1 = 0 , number2 = 0 ;
		for (i = 0 ; i < array.length ; i++) {
			var sort = true;
			for (j = 1 ; j < array.length - i ; j++) {
				if (array[j] < array[j-1] ) {
					tem = array[j-1];
					array[j-1] = array[j];
					array[j] = tem;
					sort = false;
				}
				number1 ++;
			}
			number2 ++;
			//如果没有继续变换位置，直接终止循环。
			if (sort) {
					break;
				}
		}
		console.log(array);
		console.log("数组的长度为"+array.length);
		console.log("内循环的次数为"+number1);
		console.log("外循环的次数为"+number2);
	</script>
</head>
<body>
</body>
</html>

数组的长度为14
内循环的次数为63
外循环的次数为6
```



#### 第3天 函数基础

{函数详解、函数参数和返回值、函数封装、变量作用域、函数练习}

函数知识点比较零碎繁琐，主要和循环数组结合考察。



##### 3.1 定义

函数目的：将一段公用代码封装成一个函数，减少代码（独立的JS代码被多个HTML调用）。

函数三要素：函数名称（函数功能）、参数、返回值

学习目标：函数的基本构成；用函数解决简单的问题（算法套用函数实现）



##### 3.2 使用

定义函数+调用函数

可以将公共函数放在一个独立的JS文件中，多个文件可以共用代码。

编程：将一个数学实际问题，转化成函数和数据结构（对象）。如果采用独立的JS文件，需要使用多个script标签进行（注意文件路径）。



##### 3.3 结构

function 函数名（参数）{ 函数体 }



###### 3.3.1 函数名称

函数名称是一个动作：getSum遵循驼峰原则。

为了避免函数出错，始终认为用户传入函数的值是不安全的（实际参数不符合计算要求），需要对用户输入的参数进行处理。如果a是非法数据，需要默认转化为0或者其他值（报错）进行处理。

~~~html
if (!a) {
	a = 0;
}
// 如果a是空，默认为0 （NaN Null undefined 0 false）
~~~



###### 3.3.2 健壮性

函数的健壮性：不管用户输入什么数据，保证函数不会运行错误（判断数据的合法性）。

函数输入的参数什么时候需要检验（数据是否合适）？如果个人小范围使用，知道函数输入输出的数据类型就不用检验；如果是框架中大范围使用，其他同事或者用户不清楚具体的函数，需要考验程序的健壮性。

~~~html
a = a || 0;
b = b || 0;
~~~



###### 3.3.3 函数返回值

return 参数。return标志着结束函数，return后面的代码不会执行。函数调用子函数，调用后返回到之前的函数中（断点查看代码执行过程）。

如果return后由参数（内容），返回内容；如果return后没有参数，直接返回undefined；当函数没有return，仍然会返回undefined；



##### 3.4 特殊性

###### 3.4.1 参数个数

JS函数很特殊（**实参和形参个数可以不一致**）

1.实际参数复制一份到函数中执行运算，函数中的参数发生变化后，不会改变原始代码中的参数。形式参数和实际参数在内存中占据不同的位置。

2.**JavaScript中，实参的个数和形参的个数可以不一样。**如果实参个数大于形参个数，函数调用可以取前几个参数进行计算，函数运行不会出错。如果实参的个数小于形参个数，形参中多出的函数变成undefined形式，可能影响到函数输出结果（如果函数中没有用到多余的几个形参，不会影响结果输出）。——在其他程序语言中实参个数和形参个数必须相等。

**在JavaScript中可通过—arguments .Length来检查参数的个数**，需要放在被检测函数内部（判断函数的形参个数和实参个数）。



###### 3.4.2 重载

重载：函数的名称相同，参数个数不同。JS中没有重载。JS中函数名一样，参数个数不一样，仍然是一个函数。执行过程中执行靠近代码的一个函数（前一个被层叠了，类似于CSS中样式的层叠）（JS中不能有同名的函数-了解）

调用函数时候，实参赋值一份传递给函数，不会改变实参的实际数值。



##### 3.5 函数定义方式

函数的两种定义方式：函数声明和函数表达式的区别

###### 3.5.1 函数声明

~~~html
function getSum (形式参数) {
	函数体
}
~~~

对于声明函数：为什么把函数的声明放在下面，函数在上面调用仍然可以执行（通常代码自上而下执行）？（函数表达式如果放在下面就会报错）函数进行预解析，函数可以正常执行。

###### 3.5.2 函数表达式

~~~html
var getSum = function (形式参数) {
	函数体
}；
函数表达式实质山是一个语句，预解析不涉及等号右侧代码。
var getSum = function (形式参数) { 函数体 }；
~~~

如果在函数表达式之前出现console.log（getSum）不会执行，出现参数未定义报错。参数进行预解析（var getSum）预解析中没有出现function函数，所以提示未定义变量。

使用函数表达式注意事项：

```html
var getSum;
console.log(getSum);
// undefined（弱类型语言，getSum当做变量未定义）
getSum();
// 直接报错（getSum这个函数不存在）
getSum = function () {
	程序块
}
```

如果变量未定义直接使用，undefined；函数未定义直接使用，直接报错。



##### 3.6 作用域-重点



###### 3.6.1定义

作用域：变量在什么位置能使用。



###### 3.6.2 作用域分类

JS中：全局作用域和局部作用域（全局变量和局部变量）

**局部作用域**：函数内部使用的变量；当变量超出作用范围域之后，会被销毁（回收内存程序）；

**全局作用域**：HTML代码中直接使用的参数，浏览器或者页面关闭后结束。（会长期占用内存）

**块级作用域**：一个大括号成为程序块，内部就是块级作用域。JS没有块级作用域，在块内定义的变量其他区域仍然可以使用。块级作用域通常在循环判断中存在（C语言）。

注意：JavaScript中没有块级别作用域（只有上面两种作用域，与C、java不同）——js是一种弱类型语言。JS函数内部可以访问到函数外部的变量（不是参数的变量）。



###### 3.6.3 变量分类

**局部变量**：只在函数内部使用var定义的变量。

**全局变量**：script标签内的所有变量；任何位置不使用var定义的变量。全局作用域只有一个，不管在哪个script标签内都是通用的。

函数中不使用var定义的变量，是全局变量（避免这样使用）。声明变量中带上var。

网上的解释：函数中使用var定义，就是在函数内部定义局部变量，作用域就是函数内部。如果在函数中直接使用a=5,相当于没有定义变量直接进行赋值，就会在外部全局作用域中定义一个对象，a就成为全局变量。如果在大型项目中有同名的全局变量，就会造成很大的影响，而且错误不容易查出来。所以声明局部变量是合适的。



###### 3.6.4 作用域链

作用域链：如果在函数中为定义局部变量，直接使用一个变量，首先在局部作用域中寻找这个变量，之后依次向上寻找这个变量。如果全局作用域中也没有这个变量，就会报错： A is not defined。（类似于CSS中的继承-子盒子继承父盒子的属性）



##### 3.7 预解析——考点



###### 3.7.1 预解析

预解析：定义变量，函数声明，函数参数提前，其他位置不改变（赋值，方法）——难点考点错点

**变量提升**：定义变量的时候，变量的声明会放到作用域的最上面（局部作用域或者全局作用域），变量的赋值不会提升。

**函数提升：**当前作用域中的函数提前到作用域的最前面。函数的嵌套也会造成作用域的嵌套，预解析规则不变。

**闭包**：在函数内部可以访问到函数外部的变量（面向对象高级）。（了解）



###### 3.7.2 匿名函数

没有命名的函数。在函数表达式中已经出现了匿名函数。以后使用事件用到匿名函数。

~~~html
var getSum = function (形式参数) {
	函数体
}
~~~

匿名函数自调用：函数只能使用一次，不用命名。好处：JQuary使用，避免变量命名的冲突。函数内部使用的是局部变量，不会干扰全局变量。

~~~html
(function (){ alert("hello");})  ();
~~~



##### 3.8 注意事项

1.重要的思想:前台报错不一定是前台的错误,可能是后台传过来的值导致前台报错。

有时候JS代码出现错误,会在HTML中报错,检查JS代码。（单词避免写错）

2.符号一定是英文符号，中文符号可能报错；代码较多时，括号对应关系弄清楚。



##### 3.9 练习题

函数和运算符/函数和数组/函数和循环的结合

###### 3.9.1 基本练习

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript" src="JS/main.js"></script>
	<script>
		// 练习叠加、叠乘、求最值
		console.log(getSum(1,10));
		console.log(getProduct( 1 , 5 ));
		console.log( getMax3( 1 , 10 , 5 ) );

		//求数组中的最值
		console.log("数组最值"+getArrayMax ([1,2,3,123,2,3,5,6,6]) );
		
		// 练习一
		console.log(primenumber(37));
		
		// // 练习二
		console.log(getFactorial(10));
		console.log(getFactorial(0));
		
		// // 练习三
		console.log(getFactorialsum(6));
		
		// // 练习四：getFibonocci
		console.log(getFibonocci(7));
	</script>
</head>
<body>
</body>
</html>
~~~

~~~javascript
// 例题：求数值n到m的和
function getSum (n,m) {
	//检测函数数据
	if (isNaN(n) || isNaN(m)) {
		alert("Error!please input two numbers!");
    //需要设置n是小数，m是大数
	} else {
		var sum = 0; 
		for (var i = n; i <= m; i++) {
			sum += i;
		}
	return sum;
	}
}

// Uncaught SyntaxError：Unexpected end of input 括号没有闭合

//例题：求n到m的乘积（下面习题省略数据检测）
 function getProduct (n,m) {
 	var pro = 1; 
	for (var i = n; i <= m; i++) {
		pro *=i;
	}
	return pro;
 }

 //例题：求三个数中的最大值
 function getMax3 (a,b,c) {
 	console.log(arguments.length); //结果是3
 	//使用arguments.length可以查看函数形式参数的个数（需要放在这个函数中）
 	var max = a;
 	//假设函数的最大值是第一个
 	if (b > max) {
 		max = b;
 	}
 	if (c > max) {
 		max = c;
 	}
 	return max;
 }
//可以调用getMax2函数

//例题：求两个数中的最大值
 function getMax2 (a,b) {
 	var max = a;
 	if (b > max) {
 		max = b;
 	}
 	return max;
 } 

// 求少量数据的最值，可以使用math.Max方法、三目计算法、调用简单函数方法。

 function getArrayMax (array) {
 	//判断array是否是数组（可能是字符串或者数值）以后会学到 	
 	//判断数据格式，默认值为空数组；
 	array = array || [];
	
 	//判断数组是否是空数组
 	//如果是空数组，或者数据不合适undefined，直接返回
 	//如果return后没有参数，直接返回undefined；
 	//当函数没有return仍然会返回undefined；	
 	if (array.length == 0) {
 		return false;
 	}
 		
 	var max = array[0];
 	//假设数组第一个是最大值，循环寻找最大值
 	for (var i = 1; i < array.length ; i++) {
 		if (array[i] > max) {
 			max = array[i];
 		}
 	}
 	return max;
 }

// 中英文符号一定输入正确！！！

// 练习题（函数解决）
// 默认所有给定的数据都是合理的数据
// 1.判断一个数是否是素数prime number：循环从2——根号n
/**
 * 求素数
 * @param  {[number]} num [输入数据]
 * @return {[Boolean]}    [是否是素数]
 */
function primenumber (num) {
	num = num || 0;
	//假设给定的数是质数
	var a = true;
	// i <= Math.sqrt(num); 开方更节省时间
	for (var i =2 ; i < num/2 ; i++) {
		if ( num % i == 0) {
			a = false;
			break;
		}
	}
	return a;
}

// 2.求阶乘factorial
/**
 * [阶乘factorial]
 * @param  {[number]} num [输入值]
 * @return {[number]}     [阶乘]
 */
function getFactorial (num) {
	num = num || 0;
	if (num == 0) {
		return 1;
	}
	//实际上不用上边这一步也可以
	//因为num=0的时候不会执行for循环，直接输出product就是1.
	var product = 1;
	for (i = 1; i <= num ; i++) {
		product *=i;
	}
	return product;
}

// 3.求阶乘之和（练习二叠加）
function getFactorialsum (num) {
	num = num || 0;
	if (num == 0) {
		return 1;
	}
	var product = 1;
	var sum = 0;
	//阶乘的和不包括0
	for (i = 1; i <= num ; i++) {
		product *= i;
		sum += product;
	}
	return sum;
}
//实际上练习三可以直接调用练习二的函数

// 4.求兔子数列中n项Fibonocci数列
function getFibonocci(num) {
	num = num || 0;
	if (num == 2 || num == 1) {
		return 1;
	}
	var a = 1;
	var b = 1;
	var c = 0; 
	for (i = 3; i <= num ; i++ ) {
		c = a + b;
		a = b ;
		b = c ;
	}
	return c;
}
~~~

###### 3.9.2 预解析与作用域

练习一

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
	// 第一题.请问输出什么？undefined

	var num = 10; 
	fun ();
	function fun() {
		console.log(num);
		var num = 20;
	}
	//JavaScript解析器原理：
		//预解析（全局作用域）：提前在script标签中寻找var和function和参数。将变量声明和函数声明提前到script位置（变量赋值不变），将num和function提前。
		//从上到下执行代码
		//执行到函数fun后，进入局部作用域，进行局部作用域预解析（寻找var function和参数——找到num），此时num只定义未赋值，console.log执行结果就是undefined。下面是解析器执行过程。
	var num;
	function fun() {
		var num;
		console.log(num);
		num = 20;
	}		

	number = 10; 
	fun ();		
			
	//变形：输出什么？//20
	var number = 10; 
	fun ();
	function fun() {
		var num = 20;
		console.log(num);
	}
	</script>
</head>
<body>
</body>
</html>
~~~

练习二

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<!-- 习题二 -->
	<script type="text/javascript">
		var a = 18;
		f1();
		function f1() {
			var b=9;
			console.log(a);
			console.log(b);
			var a = '123';
		}
		// 安冰解答：a undefined b 9（正确）
		// 执行过程
		var a;
		function f1() {
			var b=9;
			var a;
			console.log(a);
			console.log(b);
			a = '123';
			}

		a = 18;
		f1();
	</script>
</head>
<body>
</body>
</html>
~~~

###### 3.9.3 局部变量

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		f1();
		console.log(c);
		console.log(b);
		console.log(a);
	
	function f1 () {
		var a = b = c = 9;
		console.log(a);
		console.log(b);
		console.log(c);
	}
	//实际上解析过程 99999 a is not defined 
	//a是函数内部局部变量，bc直接赋值，属于全局变量
	function f1 () {
		var a;
		a = b = c = 9;
		// a是局部变量，bc是全局变量；
		console.log(a);
		console.log(b);
		console.log(c);
	}
	f1();
		console.log(c);
		console.log(b);
		console.log(a);
	</script>
</head>
<body>
</body>
</html>
~~~

###### 3.9.4 综合 日期判断

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//要求：给出年月日，计算这是当年的第几天？
		//年函数：是否是闰年？（如果是闰年，月份大于3，最后结果+1）
		//月函数：月份减一 使用switch——case函数，调用大月函数小月函数计算
			//大月函数+小月函数
		//日函数
		var year = prompt("请输入年");
		var month = prompt("请输入月");
		var date = prompt("请输入日");
		
		//输入数据有效性检验
		year = parseInt(1 * year);
		month = paraeInt(1 * month);
		date = parseInt(1 * date);

		console.log ( getDay(year,month,date) );
		alert ( year+"年"+month+"月"+date+"日");
		alert ( "今天是第"+getDay(year,month,date)+"天");

		function getDay (year, month ,date) {
			//转化为数值合法值
			year = year || 0;
			month = month || 1;
			date = date || 1;
			
			//判断输入数据范围
			
			//如果月份大于12或者日期大于31，提示错误。
			if (month > 12 || date > 31) {
				alert("error");
			}
			// 2月没有30日，提示错误
			if (month == 2 && date == 30) {
				alert("error");
			}
			// 闰年2月没有29日，提示错误
			if ((getYear(year) == 1) && month == 2 && date == 29) {
				alert("error");
			}
			//小月没有31日 提示错误
			if ( ((month == 4)||(month == 6)||(month == 9)||(month == 11))&&(date == 31) ) {
				alert("error");
			}

			// 以上判断通过后计算天数
			var day = 0;
			if (getYear(year) == 1 && month > 2) {
				day = getYear(year)+ getMonth(month) + getDate(date);
			}else {
				day = getMonth(month) + getDate(date);
			}
			return day;
		}

		function getYear(year) {
			//判断是否是闰年，闰年返回1 ，平年返回0.
			if ( ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0) ) {
				return 1;
			} else {
				return 0;
			}
		}

		function getMonth(month) {
			//计算月份对应的天数
			//不能计算当月数据
			var sum = 0 ;
			switch(month) {
				case 1 :
				sum = 0;
				break;
				case 2 :
				sum = getLarge();
				break;
				case 3 :
				sum = 28 + getLarge();
				break;
				case 4 :
				sum = 28 + 2 * getLarge();
				break;
				case 5 :
				sum = 2 * getLarge() + getSmall() + 28;
				break;


				case 6 :
				sum = 3 * getLarge() + getSmall() + 28;
				break;
				case 7 :
				sum = 3 * getLarge() + 2*getSmall() + 28;
				break;
				case 8 :
				sum = 4 * getLarge() + 2*getSmall() + 28;
				break;
				case 9 :
				sum = 5 * getLarge() + 2*getSmall() + 28;
				break;


				case 10 :
				sum = 5 * getLarge() + 3*getSmall() + 28;
				break;
				case 11 :
				sum = 6 * getLarge() + 3*getSmall() + 28;
				break;
				case 12 :
				sum = 6 * getLarge() + 4*getSmall() + 28;
				break;
			}
			return sum;
		}
				function getLarge() {
					return 31;
				}
				function getSmall() {
					return 30;
				}

		function getDate(date) {
			return date;
		}

	</script>
</head>
<body>
</body>
</html>
~~~

#### 第4天 递归-对象

##### 4.1 函数复习

昨天题目——日期判断

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		//使用数组记录每月的日期，直接使用switch代码较多
		//前提：用户输入数据合法合理
		console.log("是否是闰年："+runNian(2018));
		//闰年函数正确性检验
		console.log(getDays(2018,12,31) );
		//主函数
		function getDays(year, month, day) {
			var days = day;
			var months = [31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31];
			month --;
			for (var i = 0 ; i < month ; i++ ) {
				days += months[i];
			}
			if (month > 2 && runNian(year)) {
				days ++;
			}
			return days;
		}
		//闰年函数
		function runNian (year) {
			if ((year % 4 === 0 && year % 100 !== 0)||(year % 400 === 0)) {
				return true;
			}
			return false;
		}
	</script>
</head>
<body>
</body>
</html>
~~~

##### 4.2 函数递归

函数调用自己（函数的循环）必须有结束条件

每调用一次函数，形成新的局部作用域。

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>
		console.log(getFib(45));
		function getFib (n) {
			if (n ===1 || n === 2) {
				return 1;
			}
			 return (getFib(n-1) + getFib(n-2));
		}
	</script>
</head>
<body>
</body>
</html>
~~~

注意：函数的递归占用内存较多，如果循环次数较多不建议使用。

递归结构：

数列首项的计算（数值）-结束条件 

返回第n项的递推公式-循环过程



##### 4.3 函数参数

函数的数据类型是function——难点

函数也可以作为一个参数，当做另一个函数的参数；

函数可以作为另一个函数的返回值（排序sort函数使用）。

~~~javascript
声明函数
function getResult(a,b,Fn) {
	return Fn(a,b)(这是形式参数);
}

// 可以传入匿名函数

调用函数（函数表达式）
var result = getResult (5,6,function(a,b){
 return a+b ;(这是实参)
});
console.log(result);

执行步骤：
1.执行var result 
2.调用getResult函数（此时5,6，function均为实参）
3.执行getResult函数
4.getResult函数调用function函数（参数）
5.执行return a+b ;(将匿名函数function结果，返回getresult函数)
6.执行return Fn(a,b)；(将getResult函数结果，返回到result变量)
7.输出result变量（结果11）。
~~~

难点：数据的传输过程

~~~javascript
function f1 (a , fn) {
			fn(a);
		}
//可以这样理解：f1函数实际上没有实质的算法，用户给定数值参数，和函数参数，f1只完成计算的平台。
//我个人有数据，有函数（myFun），我借用公家电脑，用函数f1进行计算。

var a = 5; 
var myFun = function(a) {
	console.log(a);
};

f1(n,myFun);
~~~



程序语言基本内容（面向对象函数-除C语言之外）：

变量、数据类型、类型转换、判断、循环、数组、函数。

~~~html
面向过程语言和面向对象语言：
1.面向过程语言（C）依次执行不同的函数，按照时间先后顺序执行main函数，调用其他函数，程序的好坏在于函数的方法，循环的次数等。PHP可以面向过程，也可以面向对象。
2.面向对象函数（java-C++）（OOP object oriented programming）：总结不同对象的特点，针对不同对象使用不同的方法。规定不同对象需要遵循的规则。面向对象核心。
	2.1 封装：将属性和数据封装，提供接口。
	2.2 继承：相同的对象可以继承属性（节省代码）。
	2.3 多态：细微差别的对象不受影响。
	万物皆对象：世间一切事物都可以看做对象。
3.基于对象（JavaScript）无法创建自定义的类型，不能很好的支持继承和多态。
~~~



##### 4.4 对象

目的：将一部分数据封装，减少代码量。对象可以将不同的属性整合起来（关注属性）-难点

###### 4.4.1 基于对象

学习内置对象（DOM）目标：定义一个构造函数；创建自定义对象。

对象具有特征（电脑的颜色，配置等属性）和行为（电脑可以打开，关闭等动作）。

JS中对象：无序属性的集合

~~~html
 <!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script>

		//练习一 创建单个对象
		var hero = new Object();

		//增加属性（特征-名词）
		hero.name = "Mike";
		hero.level = 0;
		hero.diamond = 0;

		//增加行为（方法-动词）
		//函数表达式-匿名函数
		hero.moveLeft = function () {
			console.log("left");
		}
		hero.attack = function (name) {
			console.log(this.name+" attack "+name);
		}
			//攻击的对手的名字
			//this.name表示当前对象hero的名字
			//this用在当前函数的方法中
			//第二个name表示对手的名字

		//获取对象的属性值（相当于参数）
		console.log(hero.name);
		//此时不能使用this.name
		
		//使用对象的方法（相当于函数）
		hero.attack("John");
		// 类似于
		console.log("John");
		

		//练习二 创建多个对象
		/**
		 * 创建学生对象的函数
		 * @param  {[string]} name [学生姓名]
		 * @param  {[number]} age  [学生年龄]
		 * @return {[object]}      [学生对象]
		 */
		function createStudentObject(name,age) {
			var student = new Object();
			//不同对象属性不同，通过函数参数确定
			student.name = name;
			student.age = age;
			//不同对象方法相同
			student.sayHi = function() {
				console.log("Hello！My name is "+ this.name);
				console.log("I am "+ this.age + " years old.");
			}
			return student;
		}
		var student1 = createStudentObject("Amy",20);
		var student2 = createStudentObject("Tom",22);
		console.log(student1.name);
		console.log(student2.age);
		student1.sayHi();
	</script>
</head>
<body>
</body>
</html>
~~~

###### 4.4.2 创建对象

var hero = new Object();

内存中开辟空间，创建一个对象（没有属性和特定的方法）；

返回创建的对象；

构造函数的命名：第一个字母要大写；



函数和方法的区别：

直接调用的function是函数；alert( )

通过对象调用的是方法：hero.attack( )



###### 4.4.3 创建多个对象

~~~javascript
/**
		 * 创建学生对象的函数
		 * @param  {[string]} name [学生姓名]
		 * @param  {[number]} age  [学生年龄]
		 * @return {[object]}      [学生对象]
		 */
function createStudent(name,age) {
			var student = new Object();
			//不同对象属性不同，通过函数参数确定
			student.name = name;
			student.age = age;
			//不同对象方法相同
			student.sayHi = function() {
				console.log("Hello！My name is "+ this.name);
				console.log("I am "+ this.age + " years old.");
			}
			return student;
		}
		var student1 = createStudent("Amy",20);
		var student2 = createStudent("Tom",22);
		console.log(student1.name);
		console.log(student1.age);
		student1.sayHi();
~~~



###### 4.4.4 自定义构造函数

构造函数：构建一个对象并返回值的函数——重点

new Object( ); 调用构造函数 ——以后创建对象使用这种方法

~~~javascript
function Student (name, age, sex, score) {
	student.name = name;
	student.age = age;
	//不同对象方法相同
	student.sayHi = function() {
	console.log("Hello！My name is "+ this.name);
	console.log("I am "+ this.age + " years old.");
	}
}
var student1 = new Student("Mike", 18, 1, 100);
~~~
执行过程（**重要**）：

1.内存开辟空间，存储新创建的对象。

2.把this设置为当前对象（student1）

3.执行构造函数内部的代码，设置对象的属性和方法。

4.返回新创建的对象。



对象的属性，类似于变量，直接使用就行；

对象的方法，类似于函数，需要后边加上括号。

对象中的方法和属性没有顺序（数组中的数据有顺序）。



键值对（key-value pair）关键值+参数（name is key, 20 is value.）对象类似于键值对。

student.name 和 student["name"] 是等价的，一般使用第一种方法。

~~~javascript
var o = new Object();
for (var i = 0 ; i < 10 ; i++ ) {
    o["n"+i] = i;   
}
//动态增加属性：使用循环给对象增加属性，分别是n0,n1,n2——n9属性。
~~~

对象的属性可以包含基本值、对象和属性。对象就是一组没有顺序的值。对象和键值对类似，其中值可以是数据或者函数。



##### 4.5 this使用

1. p1.sayHi(); sayHi中的this，是p1,此时p1调用sayHi()。

2. 构造函数中的this，始终是new的当前对象。

3. window.test();此时this就是window，window调用test()；BOM中使用。

   ~~~javascript
   function test( ) {
   console.log(this);
   }
   test();
   ~~~


#### 第5天 对象-DOM

{对象字面量、类的介绍、for...in循环、简单类型与复杂类型的区别、复杂类型参数、DOM初体验}

##### 5.1 对象字面量

使用构造函数创建对象

~~~javascript
var student = new Object();
//使用构造函数创建对象
var arr = new Array();
//使用构造函数创建数组
var arr = [ ];
//数组的字面量
var student = { };
//对象的字面量:键值对，冒号分割
var student1 = {
name:"mike"，
age:18，
dog:{},
cat:[];
}
//值可以是数值、函数、对象
~~~

##### 5.2 json

json——JavaScript object notation——JS对象表示形式，在Ajax中经常使用，是JS的子集。

json和对象的字面量很相似：等号右侧键（属性）加上双引号。json是描述数据的一种标准规范（在php和C#中可以解析），现在简单了解。

~~~javascript
var student1 = {
"name":"mike"，
"age":18，
"dog":{},
"cat":[]
}；
~~~

不同的属性用逗号隔开，最后一个属性后不加逗号。大括号后加入分号，语句结束。

属性两种形式：student1.name 或者student1["name"] 方法一种形式：student.sayHi(a,b,c);

自己多创建对象练习

##### 5.3 伪代码：类

类：有共同属性和方法的一类事件，类似于JS中的构造函数。在面向对象程序中（C++和JAVA），使用类class创建对象。在JavaScript中没有类的概念。ECMA-6中有类。class在JS中是保留关键字。

~~~c#
c#语法创建类（了解）
class Customer {
  public String Name;
}
self.money 类似于this.money
~~~

##### 5.4 for-in遍历

如何查看（遍历）未知对象中的具体属性？

~~~javascript
var arr = new Array();
		for (var key in arr) {
			console.log(key);
          //输出arr的属性
          	console.log(o.key);
          //输出arr中属性为key的值——undefined 错误
          	console.log(o.[key]);
          //输出arr中属性的值——具体的值 正确
          //o.key == o.["key"]
		}
//for key（键） in 对象
key可以是任何变量
for-in后期用法很灵活（比较难）
~~~

for——in遍历：有的系统的对象属性和方法设置为不可以遍历（例如Array高级）。通过构造函数定义的对象可以遍历属性和方法。主要掌握for-in语法。使用for-in解决问题，直接使用console.log(arr)可以用来调试程序。

~~~html
<script>
		var obj ={};
		//新建一个对象
		for (var i = 0; i < 10; i++) {
			obj[i] = i*2;
		}
		//对象增加属性和值,如果使用.只能设置一个属性，所以使用[]
		for(var key in obj) {
			console.log(key + "==" + obj[key]);
		}
  		//遍历对象中的属性和值
  		console.log(obj[2]);
		//查看属性为2的值
</script>
~~~

总结：在新建或者遍历对象的属性时，只使用object[key]，不使用object.key.

##### 5.5 复杂数据类型-难点

复杂数据类型（引用类型）：object-array-date-function等，简单（基本）数据类型只有五个。

包装基本类型——引用类型

###### 5.5.1数据存储区别

简单数据直接存储在栈中；复杂对象将内存地址放在栈中，将具体数据放在堆中。访问简单数据比复杂数据省时间。

~~~javascript
function Student(name,age,salary) {
  this.name = name;
  this.age = age;
  this.salary = salary;
}
//构造函数新建对象
var s1 = new Student("Mike",20,2000);
var s2 = s1;
//新建s1对象，新建s2对象（实际上在堆中存储位置相同），没有调用构造函数
console.log(s2.name);
//Mike
s1.name = "John";
//改变s1对象name属性（改变堆中的数据）
console.log(s2.name);
//John

//实际上s2的属性也改变了，因为s1和s2在堆中属于一个位置。s1和s2的具体属性方法在堆中存储，内存地址在栈中存储（指针）

//简单数据类型在栈中存储，不会发生这种情况。
~~~

###### 5.5.2 函数参数区别

基本数据类型和复杂数据类型，作为函数参数的区别。

当基本数据类型作为函数的参数，函数内部对于参数的修改，不会影响全局变量的值（存储在栈中，有两个数据）。当复杂数据类型作为函数的参数，函数内部对于参数的修改，会影响原始参数的值（复制栈上的内存地址；原始数据（对象的参数）存储在堆中，只有一个原始数据），会影响外部变量。

~~~javascript
function Student(name,age,salary) {
  this.name = name;
  this.age = age;
  this.salary = salary;
}
//构造函数新建对象

function f2(stu) {
  stu.name = "ABC";
}
//新建函数

var s = new Student("Mike",18,2000);
//新建s对象

f2(s);
//将对象作为参数导入函数

console.log(s.name);
//输出-ABC
~~~

对于数组（复杂）也一样

~~~javascript
		console.log("练习二");
		function f3(arr) {
			arr[0] = -100;
		}
		//新建一个f3函数
		var array = [1,2,3,4];
		f3(array);
		//将数组（复杂）作为函数的参数
		console.log(array);
		for (j = 0 ; j <array.length ; j++) {
			console.log(array[j]);
		}
~~~

##### 5.6.内置对象-Array

内置对象——基于ECMAscript标准。JS内置对象（Math）具有一些方法。

###### 5.6.1 数组的创建

两种方法：字面量创建和构造函数创建

var Array = [1,2,3];

var array = new Array();



###### 5.6.2 数组的属性

array.length 检测数组的长度

array.isArray() 检测是否是数组（H5新增，部分浏览器不兼容）

~~~javascript
		function f1(arr) {
			//检测参数是否合法
			arr = arr || [];
			//检测arr是否是一个数组（不是字符串）
			if (!(arr instanceof Array)) {
				return;
			}
			//如果不是数组，直接返回
		}
~~~

array.toString() 直接以字符串形式输出数组

array.join(separator) 和toString 效果一致，使用分隔符号进行分隔字符串。toString方法调用join方法。



###### 5.6.3 查询方法

第一种：array还有其他方法，详细阅读参考手册（不含H5）。H5中新增加迭代方法：every filter forEach map some。具体使用查询手册（JavaScript高级程序设计-类似于字典）。

第二种：webstorm 软件平台可以查阅方法；sublime中不具有查询功能

第三种：MDN网站可以查询（Mozilla developer network）类似于维基百科，兼容早期浏览器的方法。



###### 5.6.4 判断对象类型

检测是否数组的另一个方法：instanceof

~~~javascript
		//instanceof 关键字：s是谁的对象，返回Boolean值
		var o = [];
		console.log(o instanceof Array);
		console.log(o instanceof Date);
		//返回true和false
~~~

~~~html
instanceof 和 typeof 的区别
instanceof 判断一个对象的具体类型（array、date、math），结果是boolean值
o instanceof Array
//结果true
typeof 查询一个参数的类型（number、string、object），结果是string值，不会判断object具体类型
typeof (o)
//结果object
~~~



##### 5.7 DOM入门

文档对象模型-文档树模型。DOM是操作HTML和XML的API（Application Programming Interface，应用程序编程接口，系统提供的属性和方法），可以使用JS操作HTML（添加修改移动）。

HTML可以看做一个文档树，其中的每一个分支可以看做一个对象。整个HTML代码是文档，其中的所有标签可以看做对象。



###### 5.7.1 DOM概念

文档：HTML或者XML文件

节点（node）：标签、属性、文本（回车）、注释。文档中所有内容都可以称为节点。（文本节点、属性节点）。子节点-父节点-兄弟节点

元素（element）：标签（使用最多），在JS中，标签就是element，就是一个object。

文档元素：HTML，文档中第一个元素，只有一个



###### 5.7.2 DOM级别

DOM级别了解：0-3共计4个级别，DOM的标准化。现在主要使用DOM1。



###### 5.7.3 DOM用途

寻找元素（对象-HTML标签）-设置元素的属性（样式-CSS属性）-增加减少更改元素（HTML内容）-事件（触发、响应）。

~~~html
附加：事件：动作（鼠标点击-移动-双击）

事件的触发者(事件源)-按钮
事件名称-点击
事件响应程序
~~~



###### 5.7.4 DOM美女练习

```
制作美女动态图册思想：
1.点击a标签图片（事件触发）-onclick-执行两件事情：运行showPic函数（将a标签作为参数传入函数，使用this代表a标签队对象）；终止当前href（禁止href跳转界面 return false）。
2.执行函数showPic，寻找目标对象的ID（getElementById("words")，需要改变的文本和图像）,并赋值到新的对象中（var word和img对象）。
3.将a标签的参数提取（link.href 和 link.title）,赋值到需要改变的对象中（img.src 和 word.innerText）

触发原始对象-提取原始对象的参数（标签）
寻找目标对象-提取目标对象需要改变的参数（文本或者地址）
改变目标对象的参数
```

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		/*css初始化*/
		* {
			margin:0;
			padding:0;
		}
		body {
			height: 1200px;
			background-color: rgba(230,30,100,0.2);
		}
		ul {
			list-style: none;
		}/*去掉列表中的小点*/
		h3 {
			font-size: 36px;
			text-align: center;
			font-weight: normal;
		}
		.large {
			width:1200px;
			margin: 20px auto;
		}
		.large img {
			width:1200px;
			margin: 20px auto;
		}
	</style>

</head>
<body>
	<h3>美女相册</h3>
	<br />
	<div class="small">
		<ul>
			<li><a title="美国三个少女" href="image/girl/0_137.jpg" onclick="showPic(this);return false;">
				<!-- 引用showPic函数，参数为对象a（this），return false 取消原始href效果 -->
				<img src="image/girl/0_137.jpg" ></a></li>
			<li><a title="美国四个少女" href="image/girl/1_332.jpg" onclick="showPic(this);return false;">
				<img src="image/girl/1_332.jpg" ></a></li>
			<li><a title="美国五个少女" href="image/girl/3_388.jpg" onclick="showPic(this);return false;">
				<img src="image/girl/3_388.jpg" ></a></li>
			<li><a title="美国六个少女" href="image/girl/6_934.jpg" onclick="showPic(this);return false;">
				<img src="image/girl/6_934.jpg" ></a></li>
		</ul>
	</div>
	<br />
	<h3 id="words" style="font-size:20px;">点击上面缩略图查看高清图片</h3>
	<div class="large">
		<img id="image" src="image/girl/0_137.jpg" >
		<!-- 一定注意：id和class的区别 -->
		<!-- 务必确保自己的HTML和CSS没问题 -->
		<!-- HTML和JS对接部分（标签、类、ID）完全无误 -->
	</div>

	<script>
		function showPic (link) {
			console.log(link);
			//测试link是否有效
			var img = document.getElementById("image");
			//找到id为image的对象
			console.log(img);
			//测试img对象
			img.src = link.href;
			//将link的路径给img传过去
			var word = document.getElementById("words");
			//找到id为words的对象
			console.log(word);
			//测试word对象
			word.innerText = link.title;
			//将link对象的title属性赋值到word对象的文本内部
		}
	</script>
</body>
</html>
~~~

自动生成占位图片：http://placeholder.com/350x150

###### 5.7.5 DOM操作元素

getElementById

getElementByTagName
