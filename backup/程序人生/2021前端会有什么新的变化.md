# 2021 前端会有什么新的变化？

雪碧 | github.com/doodlewind

本问题下有个自称对 2020 年「预测得很准」的回答，实在有点看不下去：

观点一：「**_Vue 3 会成为（带来高昂迁移成本与大量用户流失的）Angular 2_**」——没看出来，论据来源请求。

观点二：「**_Rust 和 WASM 不会火_**」——如果把「前端」定义为调 UI 框架做管理后台页面的岗位，那确实没火。只能说我看到了它们对浏览器外的 GUI 有非常多蓝海机会，这里不展开。

观点三：「**_Flutter 销声匿迹_**」——见下图。![img](https://pic1.zhimg.com/80/v2-82e39e7290e25b001396d2fa189da01e_1440w.jpg?source=1940ef5c)世界名画《Flutter 销声匿迹》

至于他另一个「**_2021 年什么都不会火_**」的结论，我倒觉得明明有很多 2020 年才开了个头，可以期待在 2021 年有突破性产出的东西，怎么这话题下都没人提呢……随便提几个：React 的 [Server Component](https://www.zhihu.com/question/435921124) 又提供了新的玩法，对全栈方向是重大利好，有大把的机会给新轮子（和相应的晋升 PPT）。基于 TypeScript 的[模板字符串类型](https://www.zhihu.com/question/418792736/answer/1449289960)，能一气呵成地把传统上需要搭全家桶的 Schema、Route 等细节给类型安全地搞定，写一行 `"/hello?<name:string>&<age:int>"` 路径就能拿到一个带有充分类型提示的 `request` 对象，嗯我说的就是 [@工业聚](https://www.zhihu.com/people/6751e943236c0381facaf51cf6fa1f43) 搞的 [Farrow](https://link.zhihu.com/?target=https%3A//github.com/Lucifier129/farrow)。目前已有的一些基于 Realm 或 WASM 的 Web 沙盒框架，有望形成新的技术产品——比如直接把某个（基于任意框架打包出的）JS 文件拖到可视化编辑器的页面里，就能在页面里挖个洞安全地直接渲染它。这个能力我已经眼见为实地在内部项目里看到了。[Chrome 已经能可视化断点调试 WASM 了](https://www.zhihu.com/question/434335076)，可以期待浏览器 DevTools 成为跨语言的通用调试器。日后重图形渲染类的 Hybrid 开发，确实有可能和 WASM 有更多的交集，比如有望看到一些公司对标 Figma 的大画布编辑器方案。Dart VM 去年中旬支持了 [GC Finalizer](https://link.zhihu.com/?target=https%3A//github.com/dart-lang/sdk/issues/35770)，现在已经具备像 React Native 一样把原生对象跟 Dart 绑起来做「Dart Native」的能力了。这对我们内部一些新东西很有帮助，看以后有没机会分享。基于 Rust 和 N-API，可以很好解决原生扩展易爆炸和普通前端不敢上手写的问题。把这些串起来的库 [napi-rs](https://link.zhihu.com/?target=https%3A//github.com/napi-rs/napi-rs) 才刚发布 1.0 没多久，不过作者 [@太狼](https://www.zhihu.com/people/f169ccd8ba80a296455c2c0798ec343e) 现在也已经退乎咯。但是，这些「新变化」终归都是给有兴趣和需求去接触尝鲜的少数人的。如果在日渐恶劣的大环境下不得不本分地修福报 996 糊后台管理系统 CRUD 业务的话，那确实 2021 年也是什么都不会火，恐怕只能继续「如此生活三十年，直到大厦崩塌」了吧——**逐渐发现知乎的 feed 流从经常能刷出各种有趣的前端技术讨论变成铺天盖地式地键政和声讨 996，这是我感觉到的最有冲击力的新变化**。

**ESM 大势所趋，CJS 向 ESM 过渡\*\***由 `ESM` 的普及，而带来的打包工具的革命以及适用于 ESM 下一代 CDN 的发展，业务项目在生产环境开始使用原生的 ESM 代替以前的 Bundle 方案，从而导致开发体验及网站速度的大幅提升。**核心代码就是下边这一行: 使用 `HTTP Import` 的方式代替以前的 `Bare Import` + ` Bundle``<script type="module">  import lodash from 'https://cdn.skypack.dev/lodash'; </script>  `而 `ESM` 的发展，从基建到应用的各个开发者都会参与其中:面向业务的开发者: 更改为 `Native ESM` 的最终打包方式，而非以前单一复杂的大 Bundle。网站速度变得更快 90%面向工程化的开发者: 专注于 ESM 的打包，如 Vite、ESBuild、Snowpack 等及相关插件的开发(如集成 CDN)，以及 CJS 向 ES 的过渡工作等。这使得构建效率可以提升 10 倍面向组件、库的开发者: 更多地支持 `ES` 作为前后通通用的打包方式，代替了以前的 `UMD`面向云服务的开发者: 开发新的 CDN 服务，支持最通用的 cjs-esm 及一些新特性如私有库的支持，子域名、http2/http3、审计日志做更好的收费等面向企业: 更快的网络访问速度，更便宜的 CDN (大部分资源会有公共 CDN)**面向业务**以前打包主要是两部分: `common` 打所有第三方包，`app.js` 打应用代码的包，路径带上 Hash 值，加一个永久缓存。common.xxxxxx.jsapp.xxxxxx.js**但是有可能产生一个问题: 一行代码造成整个应用的长久缓存失效。**为了对缓存进行更加细致的控制，也会小心细致的分包。如一些大包 `echarts`、`mathjax` 分出去。一些不在视觉内需要点点点才能看到的包也通过 `React.lazy`，`lodable-component` 等也给分出去。但也需要繁琐的手动配置。[分包 shanyue.tech](https://link.zhihu.com/?target=https%3A//shanyue.tech/frontend-engineering/bundle.html%23%E5%8E%9F%E5%88%99)**[HTTP 缓存控制](https://link.zhihu.com/?target=https%3A//shanyue.tech/frontend-engineering/http-cache.html)**当 `ESM` 加入后:所有第三方模块都从 CDN 中获取，且模块都会被永久缓存，而根据调查，第三方模块的体积占整个应用的 90%。为啥子可以永久缓存，因为对于 npm 的每一个 package 都会有版本号控制，版本号不变内容就不会变。现在一些支持 ESM 的 CDN 已经实现了这个功能。`$ curl --head -vvv https://jspm.dev/ms@2.1.3 cache-control: public, max-age=31536000, s-maxage=604800, immutable `CDN 使网络速度更快。以前没有 CDN 吗？以前也有，但是频率就不是一个量级了，当使用了 ESM 的 React CDN 后，React 会被各地各网站都跨网站缓存，更能充分利用到 CDN 的优势。而以前一个大的 Bundle，更有可能未命中缓存及回源**面向 Package 开发**TODO**关于 ESM 的学习**以下两篇文章可以更好地理解 ESM**[How to control the behavior of JavaScript imports](https://link.zhihu.com/?target=https%3A//github.com/WICG/import-maps)\***\*[ES modules: A cartoon deep-dive](https://link.zhihu.com/?target=https%3A//hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)**另外我做了一个网站，用以**找到更合适的轮子以及直接在控制台访问模块**。其中就使用了 `ESM` 去加载这些第三方库。[NPM Package，在这里了解 npm 包的一切 npm.devtool.tech](https://link.zhihu.com/?target=https%3A//npm.devtool.tech)比如，当我查看 `lodash`、`date-fns` 的文档时，需要去实验这些函数时，`npm.runkit` 显得不如控制台那么方便。**[lodash](https://link.zhihu.com/?target=https%3A//npm.devtoo.tech/)**，打开控制台可以直接全局访问 `lodash`- END -
