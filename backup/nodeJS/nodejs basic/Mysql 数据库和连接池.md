# Mysql 数据库和连接池

# [MySql 数据库连接池专题](https://www.cnblogs.com/aspirant/p/6747238.html)

## 一、什么是数据库连接池？

官方：[数据库](http://lib.csdn.net/base/mysql)连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。
个人理解：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。

## 二、传统的连接机制与数据库连接池的运行机制区别

传统统链接: 一般来说，Java 应用程序访问数据库的过程是：

① 装载数据库驱动程序；

② 通过 JDBC 建立数据库连接；

③ 访问数据库，执行 SQL 语句；

④ 断开数据库连接。

使用了数据库连接池的机制：

（1） 程序初始化时创建连接池
（2） 使用时向连接池申请可用连接
（3） 使用完毕，将连接返还给连接池
（4） 程序退出时，断开所有连接，并释放资源

![img](https://images2018.cnblogs.com/blog/137084/201805/137084-20180524194122461-804315041.png)

**一. 为何要使用数据库连接池**
假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。
数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.**数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个**。

数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中.

**数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素:**

1, 最小连接数:是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.
　　 2, 最大连接数:是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作
　　 3, 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被 放到连接池中等待重复使用或是空间超时后被释放.

### 二、使用数据库连接池的关键点

#### 1、并发问题

为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像 java,c#等等，使用 synchronized(java)lock(C#)关键字即可确保线程是同步的。使用方法可以参考，相关文献。

#### ２、事务处理

**DB 连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。**

我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-ALL-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。
　　我们知道当２个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。

#### ３、连接池的分配与释放

连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。
　　对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他（如何能找到最合适的连接文章将在关键议题中指出）；如果没有就抛出一个异常给用户，List 中连接是否可以被分配由一个线程来专门管理捎后我会介绍这个线程的具体实现。

#### ４、连接池的配置与维护

连接池中到底应该放置多少连接，才能使系统的性能最佳？**系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接**。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。
　　如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。

### 三、使用数据库连接池的优势和其工作原理

#### 1、连接池的优势

连接池用于创建和管理数据库连接的缓冲池技术，缓冲池中的连接可以被任何需要他们的线程使用。当一个线程需要用 JDBC 对一个数据库操作时，将从池中请求一个连接。当这个连接使用完毕后，将返回到连接池中，等待为其他的线程服务。

连接池的主要优点有以下三个方面。

第一、减少连接创建时间。连接池中的连接是已准备好的、可重复使用的，获取后可以直接访问数据库，因此减少了连接创建的次数和时间。

第二、简化的编程模式。当使用连接池时，每一个单独的线程能够像创建一个自己的 JDBC 连接一样操作，允许用户直接使用 JDBC 编程技术。

第三、控制资源的使用。如果不使用连接池，每次访问数据库都需要创建一个连接，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。连接池能够使性能最大化，将资源利用控制在一定的水平之下。连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。

#### 2、连接池的工作原理

下面，简单的阐述下连接池的工作原理。

连接池技术的核心思想是连接复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。

连接池的工作原理主要由三部分组成，分别为连接池的建立、连接池中连接的使用管理、连接池的关闭。

第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java 中提供了很多容器类可以方便的构建连接池，例如 Vector、Stack 等。

第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：

- 当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。

- 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。

  该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。

第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。

3、常用的连接池：

(1) dbcp
dbcp 可能是使用最多的开源连接池，原因大概是因为配置方便，而且很多开源和 tomcat 应用例子都是使用的这个连接池吧。
这个连接池可以设置最大和最小连接，连接等待时间等，基本功能都有。这个连接池的配置参见附件压缩包中的:dbcp.xml
使用评价：在具体项目应用中，发现此连接池的持续运行的稳定性还是可以，不过速度稍慢，在大并发量的压力下稳定性
有所下降，此外不提供连接池监控

常用的参数(**阿里面试问常用的参数**)：

我们来看 DBCP 的例子, 然后根据例子来分析:



```
#连接设置
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/day14
username=root
password=abc

#<!-- 初始化连接 -->
initialSize=10

#最大连接数量
maxActive=50

#<!-- 最大空闲连接 -->
maxIdle=20

#<!-- 最小空闲连接 -->
minIdle=5

#<!-- 超时等待时间以毫秒为单位 60000毫秒/1000等于60秒 -->
maxWait=60000


#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]
#注意："user" 与 "password" 两个属性会被明确地传递，因此这里不需要包含他们。
connectionProperties=useUnicode=true;characterEncoding=utf8

#指定由连接池所创建的连接的自动提交（auto-commit）状态。
defaultAutoCommit=true

#driver default 指定由连接池所创建的连接的只读（read-only）状态。
#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）
defaultReadOnly=

#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。
#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE
defaultTransactionIsolation=REPEATABLE_READ

DBCP配置文件
```



配置参数详解：

**MaxActive**，连接池的最大数据库连接数。设为 0 表示无限制。maxActive 是最大激活连接数，这里取值为 20，表示同时最多有 20 个数据库连　
**maxIdle** 连接池中最多可空闲 maxIdle 个连接,maxIdle 是最大的空闲连接数，这里取值为 20，表示即使没有数据库连接时依然可以保持 20 空闲的连接，而不被清除，随时处于待命状态
**minIdle** 连接池中最少空闲 maxIdle 个连接
**initialSize** 初始化连接数目
**maxWait** 连接池中连接用完时,新的请求等待时间,毫秒 MaxWait 是最大等待秒钟数，这里取值-1，表示无限等待，直到超时为止，也可取值 9000，表示 9 秒后超时。
**maxIdle**，最大空闲数，数据库连接的最大空闲时间。超过空闲时间，数据库连
接将被标记为不可用，然后被释放。设为 0 表示无限制。

(2) c3p0
c3p0 是另外一个开源的连接池，在业界也是比较有名的，这个连接池可以设置最大和最小连接，连接等待时间等，基本功能都有。
这个连接池的配置参见附件压缩包中的:c3p0.xml。
使用评价：在具体项目应用中，发现此连接池的持续运行的稳定性相当不错，在大并发量的压力下稳定性也有一定保证，
此外不提供连接池监控。

1.Apache commons-dbcp 连接池

​ 下载：http://commons.apache.org/proper/commons-dbcp/

​ 2.c3p0 数据库连接池

​ 下载：http://sourceforge.net/projects/c3p0/

程序开发过程中，存在很多问题：

首先，每一次 web 请求都要建立一次数据库连接。**建立连接是一个费时的活动，每次都得花费 0.05s ～ 1s 的时间**，而且系统还要分配内存资源。这个时间对于一次或几次数据库操作，或许感觉不出系统有多大的开销。

可是对于现在的 web 应用，尤其是大型电子商务网站，同时有几百人甚至几千人在线是很正常的事。在这种情况下，**频繁的进行数据库连接操作势必占用很多的系统资源，网站的响应速度必定下降，严重的甚至会造成服务器的崩溃**。不是危言耸听，这就是制约某些电子商务网站发展的技术瓶颈问题。其次，对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将不得不重启数据库

通过上面的分析，我们可以看出来，“数据库连接”是一种稀缺的资源，为了保障网站的正常使用，应该对其进行妥善管理。其实我们查询完数据库后，如果不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。就避免了一次建立数据库连接和断开的操作时间消耗。

**数据库连接池的基本思想**：**就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。**我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接

创建数据库连接池大概有 3 个步骤：

**① 创建 ConnectionPool 实例，并初始化创建 10 个连接，保存在 Vector 中（线程安全）单例模式实现**
② 实现 getConnection()从连接库中获取一个可用的连接
③ returnConnection(conn) 提供将连接放回连接池中方法

连接池的实现

1、连接池模型

本文讨论的连接池包括一个连接池类（DBConnectionPool）和一个连接池管理类（DBConnetionPoolManager）。连接池类是对某一数据库所有连接的“缓冲池”，主要实现以下功能：① 从连接池获取或创建可用连接；② 使用完毕之后，把连接返还给连接池；③ 在系统关闭前，断开所有连接并释放连接占用的系统资源；④ 还能够处理无效连接（原来登记为可用的连接，由于某种原因不再可用，如超时，通讯问题），并能够限制连接池中的连接总数不低于某个预定值和不超过某个预定值。

**连接池管理类是连接池类的外覆类（wrapper）,符合单例模式，即系统中只能有一个连接池管理类的实例。**其主要用于对多个连接池对象的管理，具有以下功能：① 装载并注册特定数据库的 JDBC 驱动程序；② 根据属性文件给定的信息，创建连接池对象；③ 为方便管理多个连接池对象，为每一个连接池对象取一个名字，实现连接池名字与其实例之间的映射；④ 跟踪客户使用连接情况，以便需要是关闭连接释放资源。连接池管理类的引入主要是为了方便对多个连接池的使用和管理，如系统需要连接不同的数据库，或连接相同的数据库但由于安全性问题，需要不同的用户使用不同的名称和密码。

连接池源码：

ConnectionPool.[Java](http://lib.csdn.net/base/javase)

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) View Code

ConnectionPoolUtils.java



```
/*连接池工具类，返回唯一的一个数据库连接池对象,单例模式*/
public class ConnectionPoolUtils {
    private ConnectionPoolUtils(){};//私有静态方法
    private static ConnectionPool poolInstance = null;
    public static ConnectionPool GetPoolInstance(){
        if(poolInstance == null) {
            poolInstance = new ConnectionPool(
                    "com.mysql.jdbc.Driver",
                    "jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8",
                    "root", "123456");
            try {
                poolInstance.createPool();
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        return poolInstance;
    }
}
```



ConnectionPoolTest.java

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) View Code

DBCPUtils:



```
public class DBCPUtils {
    private static DataSource ds;//定义一个连接池对象
    static{
        try {
            Properties pro = new Properties();
            pro.load(DBCPUtils.class.getClassLoader().getResourceAsStream("dbcpconfig.properties"));
            ds = BasicDataSourceFactory.createDataSource(pro);//得到一个连接池对象
        } catch (Exception e) {
            throw new ExceptionInInitializerError("初始化连接错误，请检查配置文件！");
        }
    }
    //从池中获取一个连接
    public static Connection getConnection() throws SQLException{
        return ds.getConnection();
    }

    public static void closeAll(ResultSet rs,Statement stmt,Connection conn){
        if(rs!=null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(stmt!=null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn!=null){
            try {
                conn.close();//关闭
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```



6.导入的 jar 包

commons-dbcp.jar：DBCP 实现要导入的 jar

commons-pool.jar： 连接池实现的依赖类

commons-collections.jar ：连接池实现的集合类

参考：[MySql 数据库连接池](https://www.2cto.com/database/201409/330612.html)

参考：[数据库连接池的理解](http://blog.csdn.net/wenwen091100304/article/details/48035003)

参考：[数据库连接池原理](http://blog.csdn.net/young_kim1/article/details/49947507)

参考：[Java 数据库连接池实现原理](http://blog.csdn.net/tuke_tuke/article/details/51532510)

参考：[Java 数据库连接池--DBCP 浅析.](https://www.cnblogs.com/wang-meng/p/5463020.html)

# [数据库连接池了解和常用连接池对比](https://www.cnblogs.com/whb11/p/11315463.html)

**一、.背景介绍**

什么是连接池 1)先讲一下“池”， 池(Pool)技术在一定程度上可以明显优化服务器应用程序的性能，提高程序执行效率和降低系统资源开销。这里所说的池是一种广义上的池，比如数据库连接池、线程池、内存池、对象池等。其中，对象池可以看成保存对象的容器，在进程初始化时创建一定数量的对象。需要时直接从池中取出一个空闲对象，用完后并不直接释放掉对象，而是再放到对象池中以方便下一次对象请求可以直接复用。其他几种池的设计思想也是如此，池技术的优势是，可以消除对象创建所带来的延迟，从而提高系统的性能。

为什么要使用连接池
数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等
**二，普通数据库链接和连接池的优劣对比**

## 不使用数据库连接池的步骤：

1. TCP 建立连接的三次握手
2. MySQL 认证的三次握手
3. 真正的 SQL 执行
4. MySQL 的关闭
5. TCP 的四次握手关闭

可以看到，为了执行一条 SQL，却多了非常多我们不关心的网络交互。

**优点：**
实现简单
**缺点：**
网络 IO 较多
数据库的负载较高
响应时间较长及 QPS 较低
应用频繁的创建连接和关闭连接，导致临时对象较多，GC 频繁
在关闭连接后，会出现大量 TIME_WAIT 的 TCP 状态（在 2 个 MSL 之后关闭）

## 使用连接池流程：

第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行 SQL 语句。

**优点：**

1. 较少了网络开销
2. 系统的性能会有一个实质的提升
3. 没了麻烦的 TIME_WAIT 状态

# **三、.数据库连接池的工作原理**

连接池的工作原理主要由三部分组成，分别为

1. 连接池的建立
2. 连接池中连接的使用管理
3. 连接池的关闭

第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java 中提供了很多容器类可以方便的构建连接池，例如 Vector、Stack 等。

第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：

​ 当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。

​ 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。

​ 该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。

第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，以便连接可以返回池中重复利用。我们可以通过 Connection 对象的 Close 或 Dispose 方法，也可以通过 C#的 using 语句来关闭连接。该过程正好与创建相反。

**\*移除无效连接\***

无效连接，即不能正确连接到数据库服务器的连接。对于连接池来说，存储的与数据库服务器的连接的数量是有限的。因此，对于无效连接，如果如不及时移除，将会浪费连接池的空间。其实你不用担心，连接池管理器已经很好的为我们处理了这些问题。如果连接长时间空闲，或检测到与服务器的连接已断开，连接池管理器会将该连接从池中移除。

# **四，连接池的主要参数**

最小连接数 Min Pool Size: 默认为 0。是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.
最大连接数 Max Pool Size: 默认为 100。：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作
最大空闲时间
获取连接超时时间 Connection Timeout：连接请求等待超时时间。默认为 15 秒，单位为秒。
超时重试连接次数

Pooling: 是否启用连接池。ADO.NET 默认是启用连接池的，因此，你需要手动设置 Pooling=false 来禁用连接池。

这里放一个我们项目 druid 的配置

![img](https://img2018.cnblogs.com/blog/1023532/201908/1023532-20190807141221369-1841425742.png)

![img](https://img2018.cnblogs.com/blog/1023532/201908/1023532-20190807135802773-676556350.png)

# 五，数据库对比

# 第一、二代连接池

| 数据库连接池 | 最新版本     | 发布时间 |
| ------------ | ------------ | -------- |
| c3p0         | c3p0-0.9.5.2 | 2015     |
| dbcp         | 2.2.0        | 2017     |
| druid        | 0.11.0       | 2017     |
| HikariCP     | 2.7.6        | 2018     |

表格中可以看到，c3p0 和 dbcp 等第一代基本已经死掉了， 二代产品对一代产品的超越是颠覆性的，除了一些“历史原因”，你很难再找到第二条理由说服自己不选择二代产品，但任何成功都不是偶然的，二代产品的成功很大程度上得益于前代产品们打下的基础，站在巨人的肩膀上，新一代的连接池的设计师们将这一项“工具化”的产品，推向了极致。其中，最具代表性的两款产品是：

HikariCP
Druid

彻底死掉的 C3P0
C3P0 在很长一段时间内，它一直是 Java 领域内数据库连接池的代名词，当年盛极一时的 Hibernate 都将其作为内置的数据库连接池，可以业内对它的稳定性还是认可的。C3P0 功能简单易用，稳定性好这是它的优点，但是性能上的缺点却让它彻底被打入冷宫。C3P0 的性能很差，差到即便是同时代的产品相比它也是垫底的，更不用和 Druid、HikariCP 等相比了。正常来讲，有问题很正常，改就是了，但 c3p0 最致命的问题就是架构设计过于复杂，让重构变成了一项不可能完成的任务。随着国内互联网大潮的涌起，性能有硬伤的 c3p0 彻底的退出了历史舞台。

咸鱼翻身的 DBCP
DBCP（DataBase Connection Pool）属于 Apache 顶级项目 Commons 中的核心子项目（最早在 Jakarta Commons 里就有）,在 Apache 的生态圈中的影响里十分广泛，比如最为大家所熟知的 Tomcat 就在内部集成了 DBCP，实现 JPA 规范的 OpenJPA，也是默认集成 DBCP 的。但 DBCP 并不是独立实现连接池功能的，它内部依赖于 Commons 中的另一个子项目 Pool，连接池最核心的“池”，就是由 Pool 组件提供的，因为核心功能依赖于 Pool，所以 DBCP 本身只能做小版本的更新，真正大版本的更迭则完全依托于 pool。有很长一段时间，pool 都还是停留在 1.x 版本，这直接导致 DBCP 也更新乏力。DBCP 终于靠 Pool 咸鱼翻身，打了一个漂亮的翻身仗，但长时间的等待已经完全消磨了用户的耐心，与新一代的产品项目相比，DBCP 没有任何优势，试问，谁会在有选择的前提下，去选择那个并不优秀的呢？也许，现在还选择 DBCP2 的唯一理由，就是情怀吧。

## 性能无敌的 HikariCP

HikariCP 号称“性能杀手”（It’s Faster），

那它是怎么做到如此强劲的呢？官网给出的说明如下：

字节码精简：优化代码，直到编译后的字节码最少，这样，CPU 缓存可以加载更多的程序代码；
优化代理和拦截器：减少代码，例如 HikariCP 的 Statement proxy 只有 100 行代码；
自定义数组类型（FastStatementList）代替 ArrayList：避免每次 get()调用都要进行 range check，避免调用 remove()时的从头到尾的扫描；
自定义集合类型（ConcurrentBag）：提高并发读写的效率；
其他缺陷的优化，比如对于耗时超过一个 CPU 时间片的方法调用的研究（但没说具体怎么优化）。
可以看到，上述这几点优化，和现在能找到的资料来看，HakariCP 在性能上的优势应该是得到共识的，再加上它自身小巧的身形，在当前的“云时代、微服务”的背景下，HakariCP 一定会得到更多人的青睐。

## 功能全面的 Druid

相较于其他产品，Druid 另一个比较大的优势，就是中文文档比较全面（毕竟是国人的项目么），在 github 的[_wiki\*\*页面_](https://github.com/alibaba/druid/wiki/首页)，列举了日常使用中可能遇到的问题，对一个新用户来讲，上面提供的内容已经足够指导它完成产品的配置和使用了。

现在项目开发中，我还是比较倾向于使用 Durid，它不仅仅是一个数据库连接池，它还包含一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser，所以我们项目目前用的也是这个连接池。

Druid 相对于其他数据库连接池的优点
强大的监控特性，通过 Druid 提供的监控功能，可以清楚知道连接池和 SQL 的工作情况。
a. 监控 SQL 的执行时间、ResultSet 持有时间、返回行数、更新行数、错误次数、错误堆栈信息；

b. SQL 执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个 SQL 执行了 1000 次，其中 0~1 毫秒区间 50 次，1~10 毫秒 800 次，10~100 毫秒 100 次，100~1000 毫秒 30 次，1~10 秒 15 次，10 秒以上 5 次。通过耗时区间分布，能够非常清楚知道 SQL 的执行耗时情况；

c. 监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache 命中率等。

方便扩展。Druid 提供了 Filter-Chain 模式的扩展 API，可以自己编写 Filter 拦截 JDBC 中的任何方法，可以在上面做任何事情，比如说性能监控、SQL 审计、用户名密码加密、日志等等。
Druid 集合了开源和商业数据库连接池的优秀特性，并结合阿里巴巴大规模苛刻生产环境的使用经验进行优化。

# 六，连接池需要注意的点

1、并发问题
　　为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像 java,c#等等，使用 synchronized(java)lock(C#)关键字即可确保线程是同步的。使用方法可以参考，相关文献。

2、事务处理
　　我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。
　　我们知道当 2 个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。

3、连接池的分配与释放

连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。
　　对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他（如何能找到最合适的连接文章将在关键议题中指出）；如果没有就抛出一个异常给用户，List 中连接是否可以被分配由一个线程来专门管理捎后我会介绍这个线程的具体实现。

４、连接池的配置与维护
　　连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。
　　如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。
